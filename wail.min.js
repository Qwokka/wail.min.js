const SECTION_CUSTOM=0,SECTION_TYPE=1,SECTION_IMPORT=2,SECTION_FUNCTION=3,SECTION_TABLE=4,SECTION_MEMORY=5,SECTION_GLOBAL=6,SECTION_EXPORT=7,SECTION_START=8,SECTION_ELEMENT=9,SECTION_CODE=10,SECTION_DATA=11,SECTION_DATACOUNT=12,MAX_SECTION_ID=12,KIND_FUNC=0,KIND_TABLE=1,KIND_MEMORY=2,KIND_GLOBAL=3,kindStr={func:KIND_FUNC,table:KIND_TABLE,memory:KIND_MEMORY,global:KIND_GLOBAL},convertKind=function(e){const t=kindStr[e];if(void 0===t)throw new Error("Invalid kind "+e);return t},VALUE_TYPE_I32=127,VALUE_TYPE_I64=126,VALUE_TYPE_F32=125,VALUE_TYPE_F64=124,VALUE_TYPE_ANYFUNC=112,VALUE_TYPE_FUNC=96,VALUE_TYPE_BLOCK=64,valueTypeStr={i32:127,i64:126,f32:125,f64:124,anyfunc:112,func:96,block:64},convertValueType=function(e){const t=valueTypeStr[e];if(void 0===t)throw new Error("Invalid value type "+e);return t},OP_UNREACHABLE=0,OP_NOP=1,OP_BLOCK=2,OP_LOOP=3,OP_IF=4,OP_ELSE=5,OP_END=11,OP_BR=12,OP_BR_IF=13,OP_BR_TABLE=14,OP_RETURN=15,OP_CALL=16,OP_CALL_INDIRECT=17,OP_DROP=26,OP_SELECT=27,OP_GET_LOCAL=32,OP_SET_LOCAL=33,OP_TEE_LOCAL=34,OP_GET_GLOBAL=35,OP_SET_GLOBAL=36,OP_I32_LOAD=40,OP_I64_LOAD=41,OP_F32_LOAD=42,OP_F64_LOAD=43,OP_I32_LOAD8_S=44,OP_I32_LOAD8_U=45,OP_I32_LOAD16_S=46,OP_I32_LOAD16_U=47,OP_I64_LOAD8_S=48,OP_I64_LOAD8_U=49,OP_I64_LOAD16_S=50,OP_I64_LOAD16_U=51,OP_I64_LOAD32_S=52,OP_I64_LOAD32_U=53,OP_I32_STORE=54,OP_I64_STORE=55,OP_F32_STORE=56,OP_F64_STORE=57,OP_I32_STORE8=58,OP_I32_STORE16=59,OP_I64_STORE8=60,OP_I64_STORE16=61,OP_I64_STORE32=62,OP_MEMORY_SIZE=63,OP_MEMORY_GROW=64,OP_I32_CONST=65,OP_I64_CONST=66,OP_F32_CONST=67,OP_F64_CONST=68,OP_I32_EQZ=69,OP_I32_EQ=70,OP_I32_NE=71,OP_I32_LT_S=72,OP_I32_LT_U=73,OP_I32_GT_S=74,OP_I32_GT_U=75,OP_I32_LE_S=76,OP_I32_LE_U=77,OP_I32_GE_S=78,OP_I32_GE_U=79,OP_I64_EQZ=80,OP_I64_EQ=81,OP_I64_NE=82,OP_I64_LT_S=83,OP_I64_LT_U=84,OP_I64_GT_S=85,OP_I64_GT_U=86,OP_I64_LE_S=87,OP_I64_LE_U=88,OP_I64_GE_S=89,OP_I64_GE_U=90,OP_F32_EQ=91,OP_F32_NE=92,OP_F32_LT=93,OP_F32_GT=94,OP_F32_LE=95,OP_F32_GE=96,OP_F64_EQ=97,OP_F64_NE=98,OP_F64_LT=99,OP_F64_GT=100,OP_F64_LE=101,OP_F64_GE=102,OP_I32_CLZ=103,OP_I32_CTZ=104,OP_I32_POPCNT=105,OP_I32_ADD=106,OP_I32_SUB=107,OP_I32_MUL=108,OP_I32_DIV_S=109,OP_I32_DIV_U=110,OP_I32_REM_S=111,OP_I32_REM_U=112,OP_I32_AND=113,OP_I32_OR=114,OP_I32_XOR=115,OP_I32_SHL=116,OP_I32_SHR_S=117,OP_I32_SHR_U=118,OP_I32_ROTL=119,OP_I32_ROTR=120,OP_I64_CLZ=121,OP_I64_CTZ=122,OP_I64_POPCNT=123,OP_I64_ADD=124,OP_I64_SUB=125,OP_I64_MUL=126,OP_I64_DIV_S=127,OP_I64_DIV_U=128,OP_I64_REM_S=129,OP_I64_REM_U=130,OP_I64_AND=131,OP_I64_OR=132,OP_I64_XOR=133,OP_I64_SHL=134,OP_I64_SHR_S=135,OP_I64_SHR_U=136,OP_I64_ROTL=137,OP_I64_ROTR=138,OP_F32_ABS=139,OP_F32_NEG=140,OP_F32_CEIL=141,OP_F32_FLOOR=142,OP_F32_TRUNC=143,OP_F32_NEAREST=144,OP_F32_SQRT=145,OP_F32_ADD=146,OP_F32_SUB=147,OP_F32_MUL=148,OP_F32_DIV=149,OP_F32_MIN=150,OP_F32_MAX=151,OP_F32_COPYSIGN=152,OP_F64_ABS=153,OP_F64_NEG=154,OP_F64_CEIL=155,OP_F64_FLOOR=156,OP_F64_TRUNC=157,OP_F64_NEAREST=158,OP_F64_SQRT=159,OP_F64_ADD=160,OP_F64_SUB=161,OP_F64_MUL=162,OP_F64_DIV=163,OP_F64_MIN=164,OP_F64_MAX=165,OP_F64_COPYSIGN=166,OP_I32_WRAP_I64=167,OP_I32_TRUNC_S_F32=168,OP_I32_TRUNC_U_F32=169,OP_I32_TRUNC_S_F64=170,OP_I32_TRUNC_U_F64=171,OP_I64_EXTEND_S_I32=172,OP_I64_EXTEND_U_I32=173,OP_I64_TRUNC_S_F32=174,OP_I64_TRUNC_U_F32=175,OP_I64_TRUNC_S_F64=176,OP_I64_TRUNC_U_F64=177,OP_F32_CONVERT_S_I32=178,OP_F32_CONVERT_U_I32=179,OP_F32_CONVERT_S_I64=180,OP_F32_CONVERT_U_I64=181,OP_F32_DEMOTE_F64=182,OP_F64_CONVERT_S_I32=183,OP_F64_CONVERT_U_I32=184,OP_F64_CONVERT_S_I64=185,OP_F64_CONVERT_U_I64=186,OP_F64_PROMOTE_F32=187,OP_I32_REINTERPRET_F32=188,OP_I64_REINTERPRET_F64=189,OP_F32_REINTERPRET_I32=190,OP_F64_REINTERPRET_I64=191,OP_I32_EXTEND8_S=192,OP_I32_EXTEND16_S=193,OP_I64_EXTEND8_S=194,OP_I64_EXTEND16_S=195,OP_I64_EXTEND32_S=196,OP_BULK_MEMORY=252,OP_ATOMIC=254,ARG_MEMORY_INIT=8,ARG_DATA_DROP=9,ARG_MEMORY_COPY=10,ARG_MEMORY_FILL=11,ARG_TABLE_INIT=12,ARG_ELEM_DROP=13,ARG_TABLE_COPY=14,ARG_ATOMIC_WAKE=0,ARG_I32_ATOMIC_WAIT=1,ARG_I64_ATOMIC_WAIT=2,ARG_I32_ATOMIC_LOAD=16,ARG_I64_ATOMIC_LOAD=17,ARG_I32_ATOMIC_LOAD_8U=18,ARG_I32_ATOMIC_LOAD_16U=19,ARG_I64_ATOMIC_LOAD_8U=20,ARG_I64_ATOMIC_LOAD_16U=21,ARG_I64_ATOMIC_LOAD_32U=22,ARG_I32_ATOMIC_STORE=23,ARG_I64_ATOMIC_STORE=24,ARG_I32_ATOMIC_STORE_8=25,ARG_I32_ATOMIC_STORE_16=26,ARG_I64_ATOMIC_STORE_8=27,ARG_I64_ATOMIC_STORE_16=28,ARG_I64_ATOMIC_STORE_32=29,ARG_I32_ATOMIC_RMW_ADD=30,ARG_I64_ATOMIC_RMW_ADD=31,ARG_I32_ATOMIC_RMW_ADD_8U=32,ARG_I32_ATOMIC_RMW_ADD_16U=33,ARG_I64_ATOMIC_RMW_ADD_8U=34,ARG_I64_ATOMIC_RMW_ADD_16U=35,ARG_I64_ATOMIC_RMW_ADD_32U=36,ARG_I32_ATOMIC_RMW_SUB=37,ARG_I64_ATOMIC_RMW_SUB=38,ARG_I32_ATOMIC_RMW_SUB_8U=39,ARG_I32_ATOMIC_RMW_SUB_16U=40,ARG_I64_ATOMIC_RMW_SUB_8U=41,ARG_I64_ATOMIC_RMW_SUB_16U=42,ARG_I64_ATOMIC_RMW_SUB_32U=43,ARG_I32_ATOMIC_RMW_AND=44,ARG_I64_ATOMIC_RMW_AND=45,ARG_I32_ATOMIC_RMW_AND_8U=46,ARG_I32_ATOMIC_RMW_AND_16U=47,ARG_I64_ATOMIC_RMW_AND_8U=48,ARG_I64_ATOMIC_RMW_AND_16U=49,ARG_I64_ATOMIC_RMW_AND_32U=50,ARG_I32_ATOMIC_RMW_OR=51,ARG_I64_ATOMIC_RMW_OR=52,ARG_I32_ATOMIC_RMW_OR_8U=53,ARG_I32_ATOMIC_RMW_OR_16U=54,ARG_I64_ATOMIC_RMW_OR_8U=55,ARG_I64_ATOMIC_RMW_OR_16U=56,ARG_I64_ATOMIC_RMW_OR_32U=57,ARG_I32_ATOMIC_RMW_XOR=58,ARG_I64_ATOMIC_RMW_XOR=59,ARG_I32_ATOMIC_RMW_XOR_8U=60,ARG_I32_ATOMIC_RMW_XOR_16U=61,ARG_I64_ATOMIC_RMW_XOR_8U=62,ARG_I64_ATOMIC_RMW_XOR_16U=63,ARG_I64_ATOMIC_RMW_XOR_32U=64,ARG_I32_ATOMIC_RMW_XCHG=65,ARG_I64_ATOMIC_RMW_XCHG=66,ARG_I32_ATOMIC_RMW_XCHG_8U=67,ARG_I32_ATOMIC_RMW_XCHG_16U=68,ARG_I64_ATOMIC_RMW_XCHG_8U=69,ARG_I64_ATOMIC_RMW_XCHG_16U=70,ARG_I64_ATOMIC_RMW_XCHG_32U=71,ARG_I32_ATOMIC_RMW_CMPXCHG=72,ARG_I64_ATOMIC_RMW_CMPXCHG=73,ARG_I32_ATOMIC_RMW_CMPXCHG_8U=74,ARG_I32_ATOMIC_RMW_CMPXCHG_16U=75,ARG_I64_ATOMIC_RMW_CMPXCHG_8U=76,ARG_I64_ATOMIC_RMW_CMPXCHG_16U=77,ARG_I64_ATOMIC_RMW_CMPXCHG_32U=78,convertOpcode=function(e){const t=opcodeStr[e];if(void 0===t)throw new Error("Invalid opcode "+e);return t},convertOpcodeArray=function(e){const t=[];for(let i=0;i<e.length;i++){const r=e[i];let n=r;"string"==typeof r&&(n=convertOpcode(r)),t.push(n)}return t},Uint8ToArray=function(e){return[255&e]},Uint32ToArray=function(e){return[255&e,(65280&e)>>8,(16711680&e)>>16,(4278190080&e)>>24]},Uint64ToArray=function(e){return[255&e,(65280&e)>>8,(16711680&e)>>16,(4278190080&e)>>24,(0xff00000000&e)>>32,(0xff0000000000&e)>>40,(0xff000000000000&e)>>48,(0xff00000000000000&e)>>56]},VarUint32ToArray=function(e){const t=[];let i=e;if(0==e)return[0];for(;i>0;){let e=127&i;(i>>=7)&&(e|=128),t.push(e)}return t},VarSint32ToArray=function(e){const t=[];let i=e;for(;;){if(thisByte=127&i,-1==(i>>=7)&&64&thisByte){t.push(thisByte);break}if(!(0!=i||64&thisByte)){t.push(thisByte);break}thisByte|=128,t.push(thisByte)}return t},stringToByteArray=function(e){return e.split("").map(function(e){return e.charCodeAt(0)})},VarUint32=function(e){return"number"==typeof e?VarUint32ToArray(e):e instanceof WailVariable?e.varUint32():void 0};class WailVariable{constructor(){this._value=null}get value(){if(null===this._value)throw new Error("Attempted to resolve WailVariable before set");return this._value}set value(e){this._value=e}i32(){return null!==this._value?this.value:new WailI32(this)}f32(){if(null!==this._value){const e=new Float32Array([this._value]);return new Uint8Array(e.buffer)}return new WailF32(this)}i64(){return null!==this._value?this.value:new WailI64(this)}f64(){if(null!==this._value){const e=new Float64Array([this._value]);return new Uint8Array(e.buffer)}return new WailF64(this)}varUint32(){return null!==this._value?VarUint32(this.value):new WailVarUint32(this)}}class TypedWailVariable{constructor(e){this._parent=e}}class WailI32 extends TypedWailVariable{get value(){return Uint32ToArray(this._parent.value)}}class WailF32 extends TypedWailVariable{get value(){return Uint32ToArray(this._parent.value)}}class WailI64 extends TypedWailVariable{get value(){return Uint64ToArray(this._parent.value)}}class WailF64 extends TypedWailVariable{get value(){return Uint64ToArray(this._parent.value)}}class WailVarUint32 extends TypedWailVariable{get value(){return VarUint32ToArray(this._parent.value)}}const BufferReader=class{constructor(e){this.inBuffer=null,this.outBuffer=null,void 0!==e?(this.inBuffer=new Uint8Array(e),this.outBuffer=new Uint8Array(2*e.length)):this.outBuffer=new Uint8Array(1),this.inPos=0,this._copyPos=0,this.outPos=0,this._anchor=null}load(e){this.inBuffer=new Uint8Array(e),this.outBuffer=new Uint8Array(2*this.inBuffer.length)}resize(){if(0==this.outBuffer.length)throw new Error("Attempted to resize 0-length buffer");const e=new Uint8Array(Math.ceil(1.25*this.outBuffer.length));for(let t=0;t<this.outPos;t++)e[t]=this.outBuffer[t];this.outBuffer=e}readUint8(){return this.inBuffer[this.inPos++]}readUint32(){return this.inBuffer[this.inPos++]|this.inBuffer[this.inPos++]<<8|this.inBuffer[this.inPos++]<<16|this.inBuffer[this.inPos++]<<24}readVarUint32(){let e,t=0,i=0;do{t|=(127&(e=this.readUint8()))<<i,i+=7}while(128&e);return t}readUint64(){return this.inBuffer[this.inPos++]|this.inBuffer[this.inPos++]<<8|this.inBuffer[this.inPos++]<<16|this.inBuffer[this.inPos++]<<24|this.inBuffer[this.inPos++]<<32|this.inBuffer[this.inPos++]<<40|this.inBuffer[this.inPos++]<<48|this.inBuffer[this.inPos++]<<56}readBytes(e){const t=new Uint8Array(e);for(let i=0;i<e;i++)t[i]=this.inBuffer[this.inPos++];return t}copyBuffer(e){for(;e.length+this.outPos>this.outBuffer.length;)this.resize();for(let t=0;t<e.length;t++,this.outPos++)this.outBuffer[this.outPos]=e[t];this.updateCopyPosition()}commitBytes(){for(;this.inPos-this._copyPos+this.outPos>this.outBuffer.length;)this.resize();for(;this._copyPos<this.inPos;this._copyPos++,this.outPos++)this.outBuffer[this.outPos]=this.inBuffer[this._copyPos]}updateCopyPosition(){this._copyPos=this.inPos}setAnchor(){this._anchor=this.outPos}readFromAnchor(){return this.outBuffer.slice(this._anchor,this.outPos)}writeAtAnchor(e){for(;e.length+this.outPos>this.outBuffer.length;)this.resize();for(let t=0;t<e.length;t++)this.outBuffer[this._anchor+t]=e[t];this.outPos=this._anchor+e.length}write(){return this.outBuffer.slice(0,this.outPos)}};class WailParser extends BufferReader{constructor(e){super(e),this._finished=!1,this._newSections=[],this._removeSectionIds=[],this._resolvedTables=!1,this._importFuncCount=0,this._importFuncNewCount=0,this._importGlobalCount=0,this._importGlobalNewCount=0,this._globalFunctionCallback=null,this._functionCallbacks=[],this._globalInstructionCallback=null,this._instructionCallbacks={},this._sectionOptions={};for(let e=0;e<=MAX_SECTION_ID;e++)this._sectionOptions[e]={newEntries:[],existingEntries:[],pending:[]};this._requiredSectionFlags=0,this._optionalSectionFlags=0,this._parsedSections=0,this.__variables=[]}parse(){const e=this.readUint32();this.readUint32();if(1836278016!=e)throw new Error("Invalid magic. Probably not a WebAssembly binary");for(;this.inPos<this.inBuffer.length;)this._readSection();this.commitBytes(),this._finished=!0}removeSection(e){if("number"!=typeof e)throw new Error("Invalid argument to removeSection()");this._removeSectionIds.push(e)}addTypeEntry(e){const t={},i=e.form;t.form="number"==typeof i?i:convertValueType(i);const r=e.params;if(r instanceof Array){const e=[];for(let t=0;t<r.length;t++){const i=r[t];"number"==typeof i?e.push(i):e.push(convertValueType(i))}t.params=e}else t.params=[];const n=e.returnType;"number"==typeof n?t.returnType=n:"string"==typeof n&&(t.returnType=convertValueType(n));const _=this._createVariable();return t.variable=_,this._sectionOptions[SECTION_TYPE].newEntries.push(t),this._requiredSectionFlags|=1<<SECTION_TYPE,_}editTypeEntry(e,t){const i={};if("number"!=typeof e)throw new Error("Invalid index in editTypeEntry()");i.index=e;const r=t.params;r instanceof Array?i.params=r:i.params=[];const n=t.returnType;n&&(i.returnType=n),this._sectionOptions[SECTION_TYPE].existingEntries.push(i),this._optionalSectionFlags|=1<<SECTION_TYPE}addImportEntry(e){const t={},i=e.moduleStr;if(!("string"==typeof i||i instanceof String))throw new Error("Invalid moduleStr");t.moduleStr=i;const r=e.fieldStr;if(!("string"==typeof r||r instanceof String))throw new Error("Invalid fieldStr");t.fieldStr=r;const n=e.kind;let _;_="number"==typeof n?n:convertKind(n);let a=e.type;switch(t.kind=_,_){case KIND_FUNC:if(this._importFuncNewCount++,"number"==typeof a)t.type=a;else if(a instanceof WailVarUint32)t.type=a;else{if(!(a instanceof WailVariable))throw new Error("Invalid type");t.type=a.varUint32()}break;case KIND_GLOBAL:if(this._importGlobalNewCount++,"number"!=typeof a)throw new Error("Invalid type");if(t.type=a,0!==e.mutability&&1!==e.mutability&&!0!==e.mutability&&!1!==e.mutability)throw new Error("Invalid mutability");t.mutability=e.mutability;break;case KIND_MEMORY:throw new Error("Adding new memory object not currently supported");case KIND_TABLE:throw new Error("Adding new table object not currently supported");default:throw new Error("Invalid kind")}const o=this._createVariable();return t.variable=o,this._sectionOptions[SECTION_IMPORT].newEntries.push(t),this._requiredSectionFlags|=1<<SECTION_IMPORT,this._importFuncNewCount>0&&(this._optionalSectionFlags|=1<<SECTION_EXPORT,this._optionalSectionFlags|=1<<SECTION_ELEMENT,this._optionalSectionFlags|=1<<SECTION_CODE,this._optionalSectionFlags|=1<<SECTION_START),this._importGlobalNewCount>0&&(this._optionalSectionFlags|=1<<SECTION_EXPORT,this._optionalSectionFlags|=1<<SECTION_CODE),o}editImportEntry(e,t){const i={};if(i.index=e,"number"!=typeof e&&!(e instanceof WailVariable))throw new Error("Invalid index in editImportEntry()");const r=t.moduleStr;("string"==typeof r||r instanceof String)&&(i.moduleStr=stringToByteArray(r));const n=t.fieldStr;("string"==typeof n||n instanceof String)&&(i.fieldStr=stringToByteArray(n)),this._sectionOptions[SECTION_IMPORT].existingEntries.push(i),this._optionalSectionFlags|=1<<SECTION_IMPORT}addFunctionEntry(e){const t={},i=e.type;if("number"==typeof i)t.type=i;else if(i instanceof WailVarUint32)t.type=i;else{if(!(i instanceof WailVariable))throw new Error("Invalid type");t.type=i.varUint32()}const r=this._createVariable();return t.variable=r,this._sectionOptions[SECTION_FUNCTION].newEntries.push(t),this._requiredSectionFlags|=1<<SECTION_FUNCTION,r}editFunctionEntry(e,t){const i={};if(i.index=e,"number"!=typeof e&&!(e instanceof WailVariable))throw new Error("Invalid index in editFunctionEntry()");const r=t.type;if("number"!=typeof r)throw new Error("Invalid type in editFunctionEntry()");i.type=r,this._sectionOptions[SECTION_FUNCTION].existingEntries.push(i),this._optionalSectionFlags|=1<<SECTION_FUNCTION}getFunctionIndex(e){if(this._finished){if(e instanceof WailVariable)return e;{const t=this._createVariable;return t.value=this._getAdjustedFunctionIndex(e),t}}const t=this._createVariable();if("number"!=typeof e)throw new Error("Invalid index in getFunctionIndex()");const i={oldIndex:e,variable:t};return this._sectionOptions[SECTION_FUNCTION].pending.push(i),this._optionalSectionFlags|=1<<SECTION_IMPORT,t}addGlobalEntry(e){const t={globalType:{}};if(void 0===e.globalType)throw new Error("Invalid globalType");"number"==typeof e.globalType.contentType?t.globalType.contentType=e.globalType.contentType:t.globalType.contentType=convertValueType(e.globalType.contentType);const i=e.globalType.mutability;if(1==i)t.globalType.mutability=1;else{if(0!=i)throw new Error("Invalid mutability");t.globalType.mutability=0}e.initExpr instanceof Array?t.initExpr=convertOpcodeArray(e.initExpr):t.initExpr=[OP_I32_CONST,VarUint32(0),OP_END];const r=this._createVariable();return t.variable=r,this._sectionOptions[SECTION_GLOBAL].newEntries.push(t),this._requiredSectionFlags|=1<<SECTION_GLOBAL,r}editGlobalEntry(e,t){const i={};if("number"==typeof e)console.warn("Using raw indexes in editGlobalEntry() can have unpredictable results. Consider using getGlobalIndex() instead");else if(!(e instanceof WailVariable))throw new Error("Invalid globalIndex in addCodeEntry()");if(i.index=e,i.globalType={},void 0===t.globalType)throw new Error("Invalid globalType");"number"==typeof t.globalType.contentType?i.globalType.contentType=t.globalType.contentType:i.globalType.contentType=convertValueType(t.globalType.contentType);const r=t.globalType.mutability;if(1==r)i.globalType.mutability=1;else{if(0!=r)throw new Error("Invalid mutability");i.globalType.mutability=0}this._sectionOptions[SECTION_GLOBAL].existingEntries.push(i),this._requiredSectionFlags|=1<<SECTION_GLOBAL}getGlobalIndex(e){if(this._finished)return e instanceof WailVariable?e.value:this._getAdjustedGlobalIndex(e);const t=this._createVariable();if("number"!=typeof e)throw new Error("Invalid index in getGlobalIndex()");const i={oldIndex:e,variable:t};return this._sectionOptions[SECTION_GLOBAL].pending.push(i),this._optionalSectionFlags|=1<<SECTION_IMPORT,t}addExportEntry(e,t){const i={};if(!("string"==typeof t.fieldStr||t.fieldStr instanceof String))throw new Error("Invalid fieldStr");if(i.fieldStr=t.fieldStr,"number"==typeof t.kind?i.kind=t.kind:i.kind=convertKind(t.kind),"number"==typeof e)i.index=e;else if(e instanceof WailVarUint32)i.index=e;else{if(!(e instanceof WailVariable))throw new Error("Invalid type");i.index=e.varUint32()}const r=this._createVariable();return i.variable=r,this._sectionOptions[SECTION_EXPORT].newEntries.push(i),this._requiredSectionFlags|=1<<SECTION_EXPORT,r}editExportEntry(e,t){const i={};if(i.index=e,"number"!=typeof e&&!(e instanceof WailVariable))throw new Error("Invalid index in editExportEntry()");const r=t.fieldStr;("string"==typeof r||r instanceof String)&&(i.fieldStr=stringToByteArray(r)),i.kind=t.kind,i.funcIndex=t.index,this._sectionOptions[SECTION_EXPORT].existingEntries.push(i),this._optionalSectionFlags|=1<<SECTION_EXPORT}editStartEntry(e){if("number"!=typeof e&&!(e instanceof WailVariable))throw new Error("Invalid index in editStartEntry()");this._sectionOptions[SECTION_START].existingEntries.push(e),this._requiredSectionFlags|=1<<SECTION_START}addElementEntry(e){const t=this._createVariable();return e.variable=t,this._sectionOptions[SECTION_ELEMENT].newEntries.push(e),this._requiredSectionFlags|=1<<SECTION_ELEMENT,t}editElementEntry(e,t){const i={};if(i.index=e,"number"!=typeof e&&!(e instanceof WailVariable))throw new Error("Invalid index in editElementEntry()");i.elems=[],this._sectionOptions[SECTION_ELEMENT].existingEntries.push(i),this._optionalSectionFlags|=1<<SECTION_ELEMENT}addCodeEntry(e,t){const i={};if("number"==typeof e)console.warn("Using raw indexes in addCodeEntry() can have unpredictable results. Consider using getFunctionIndex() instead");else if(!(e instanceof WailVariable))throw new Error("Invalid funcIndex in addCodeEntry()");i.index=e;const r=t.locals;if(r instanceof Array){const e=[];for(let t=0;t<r.length;t++){const i=r[t];if("number"==typeof i)e.push(i);else{if("string"!=typeof i)throw new Error("Invalid local entry in addCodeEntry()");e.push(convertValueType(i))}}i.locals=e}else i.locals=[];const n=t.code;if(!(n instanceof Array))throw new Error("Invalid code");i.code=convertOpcodeArray(n);const _=this._createVariable();return i.variable=_,this._sectionOptions[SECTION_CODE].newEntries.push(i),this._requiredSectionFlags|=1<<SECTION_CODE,_}editCodeEntry(e,t){const i={};if("number"==typeof e)console.warn("Using raw indexes in editCodeEntry() can have unpredictable results. Consider using getFunctionIndex() instead");else if(!(e instanceof WailVariable))throw new Error("Invalid funcIndex in addCodeEntry()");i.index=e;const r=t.locals;if(r instanceof Array){const e=[];for(let t=0;t<r.length;t++){const i=r[t];if("number"==typeof i)e.push(i);else{if("string"!=typeof i)throw new Error("Invalid local entry in addCodeEntry()");e.push(convertValueType(i))}}i.locals=e}else i.locals=[];const n=t.code;if(!(n instanceof Array))throw new Error("Invalid code");i.code=convertOpcodeArray(n),this._sectionOptions[SECTION_CODE].existingEntries.push(i),this._optionalSectionFlags|=1<<SECTION_IMPORT,this._optionalSectionFlags|=1<<SECTION_CODE}addDataEntry(e){const t=this._createVariable();return e.variable=t,this._sectionOptions[SECTION_DATA].newEntries.push(e),this._requiredSectionFlags|=1<<SECTION_DATA,t}editDataEntry(e,t){const i={};if("number"!=typeof e)throw new Error("Invalid index in editTypeEntry()");i.index=e,"string"==typeof t.data?i.data=stringToByteArray(t.data):i.data=t.data,this._sectionOptions[SECTION_DATA].existingEntries.push(i),this._optionalSectionFlags|=1<<SECTION_DATA}addCodeElementParser(e,t){if("function"!=typeof t)throw new Error("Bad callback in addCodeElementParser()");if(null===e)this._globalFunctionCallback=t;else{if(!("number"==typeof e||e instanceof WailVariable))throw new Error("Bad id "+e+" in addCodeElementParser()");{const i={};i.index=e,i.callback=t,this._functionCallbacks.push(i)}}this._optionalSectionFlags|=1<<SECTION_IMPORT,this._optionalSectionFlags|=1<<SECTION_CODE}addInstructionParser(e,t){if("function"!=typeof t)throw new Error("Bad callback in addInstructionParser()");if(null===e)this._globalInstructionCallback=t;else{if(isNaN(e)&&!(e instanceof WailVariable))throw new Error("Bad opcode "+e+" in addCodeElementParser()");this._instructionCallbacks[e]=t}this._optionalSectionFlags|=1<<SECTION_CODE}addRawSection(e,t){const i={};if("number"!=typeof e)throw new Error("Bad section index "+index+" in addRawSection()");i.id=e,i.bytes=t,this._newSections.push(i)}_createVariable(){const e=this.__variables.length,t=new WailVariable(this,e);return this.__variables.push(t),t}_getVariable(e){return this.__variables[e]}_setVariable(e,t){this.__variables[e]=t}_expandArrayVariables(e){for(let t=0;t<e.length;t++){const i=e[t];if(i instanceof Array)e.splice(t,1),e.splice(t,0,...i);else if(i instanceof TypedWailVariable){const r=i;e.splice(t,1),e.splice(t,0,...r.value)}else if(i instanceof WailVariable)throw new Error("Untyped WailVariable in _expandArrayVariables()")}return e}_readSection(){this.commitBytes();const e=this.readUint8();if(e>MAX_SECTION_ID)throw new Error("Illegal section ID "+e+". Probably parsing incorrectly");let t;if(this._removeSectionIds.includes(e))return t=this.readVarUint32(),this.readBytes(t),void this.updateCopyPosition();let i=!1;if((this._requiredSectionFlags&1<<e||this._optionalSectionFlags&1<<e)&&(i=!0),e!=SECTION_DATACOUNT)for(let t=0;t<e;t++){const i=1<<t,r=this._requiredSectionFlags&i;if(r&&!(r&this._parsedSections)){switch(t){case SECTION_TYPE:this._addTypeSection();break;case SECTION_IMPORT:this._addImportSection();break;case SECTION_FUNCTION:this._addFunctionSection();break;case SECTION_GLOBAL:this._addGlobalSection();break;case SECTION_EXPORT:this._addExportSection();break;case SECTION_START:this._addStartSection();break;case SECTION_ELEMENT:this._addElementSection();break;case SECTION_CODE:this._addCodeSection();break;case SECTION_DATA:this._addDataSection();break;default:throw new Error("Attempted to add unhandled section")}this._parsedSections|=i,this.copyBuffer([e])}}for(let t=0;t<this._newSections.length;t++){const i=this._newSections[t];if(e>i.id){const e=i.bytes,t=VarUint32ToArray(e.length);this.copyBuffer([i.id]),this.copyBuffer(t),this.copyBuffer(e)}}if(!i)return t=this.readVarUint32(),void this.readBytes(t);switch(e>SECTION_IMPORT&&0==this._resolvedTables&&this._resolveTableIndices(),e){case SECTION_TYPE:this._parseTypeSection();break;case SECTION_IMPORT:this._parseImportSection();break;case SECTION_FUNCTION:this._parseFunctionSection();break;case SECTION_GLOBAL:this._parseGlobalSection();break;case SECTION_EXPORT:this._parseExportSection();break;case SECTION_START:this._parseStartSection();break;case SECTION_ELEMENT:this._parseElementSection();break;case SECTION_CODE:this._parseCodeSection();break;case SECTION_DATA:this._parseDataSection();break;default:throw new Error("Attempted to parse unhandled section")}this._parsedSections|=1<<e}_resolveTableIndices(){const e=this._sectionOptions[SECTION_FUNCTION].pending;for(let t=0;t<e.length;t++){const i=e[t].oldIndex;e[t].variable.value=this._getAdjustedFunctionIndex(i)}const t=this._sectionOptions[SECTION_GLOBAL].pending;for(let e=0;e<t.length;e++){const i=t[e].oldIndex;t[e].variable.value=this._getAdjustedGlobalIndex(i)}this._resolvedTables=!0}_addTypeSection(){const e=new BufferReader,t=this._sectionOptions[SECTION_TYPE].newEntries,i=VarUint32ToArray(t.length);e.copyBuffer(i);for(let i=0;i<t.length;i++){const r=t[i],n=r.form,_=r.params;let a=null;void 0!==r.returnType&&(a=r.returnType),r.variable instanceof WailVariable&&(r.variable.value=oldCount+i),e.copyBuffer(Uint8ToArray(n)),e.copyBuffer(VarUint32ToArray(_.length)),e.copyBuffer(_),null!==a?(e.copyBuffer(Uint8ToArray(1)),e.copyBuffer(Uint8ToArray(a))):e.copyBuffer(Uint8ToArray(0))}const r=e.write(),n=VarUint32ToArray(r.length);this.copyBuffer([SECTION_TYPE]),this.copyBuffer(n),this.copyBuffer(r)}_parseTypeSection(){this.commitBytes();const e=this.readVarUint32(),t=this.inPos,i=this.readVarUint32(),r=this.inPos-t,n=this.readBytes(e-r),_=new BufferReader(n),a=this._sectionOptions[SECTION_TYPE].newEntries,o=this._sectionOptions[SECTION_TYPE].existingEntries,s=i+a.length;_.copyBuffer(VarUint32ToArray(s));for(let e=0;e<i;e++){const t=_.readUint8();let i=_.readVarUint32(),r=[];for(let e=0;e<i;e++)r.push(_.readUint8());let n=_.readUint8(),a=null;if(1==n)a=_.readUint8();else if(0!=n)throw new Error("Invalid returnCount");for(let t=0;t<o.length;t++){const i=o[t];e==i.index&&(void 0!==i.params&&(r=mod.params),void 0!==i.returnType&&(n=1,a=mod.returnType))}_.copyBuffer(Uint8ToArray(t)),_.copyBuffer(VarUint32ToArray(r.length)),_.copyBuffer(r),n?(_.copyBuffer(Uint8ToArray(1)),_.copyBuffer(Uint8ToArray(a))):_.copyBuffer(Uint8ToArray(0))}for(let e=0;e<a.length;e++){const t=a[e],r=t.form,n=t.params;let o=null;void 0!==t.returnType&&(o=t.returnType),t.variable instanceof WailVariable&&(t.variable.value=i+e),_.copyBuffer(Uint8ToArray(r)),_.copyBuffer(VarUint32ToArray(n.length)),_.copyBuffer(n),null!==o?(_.copyBuffer(Uint8ToArray(1)),_.copyBuffer(Uint8ToArray(o))):_.copyBuffer(Uint8ToArray(0))}const c=_.write(),l=VarUint32ToArray(c.length);this.copyBuffer(l),this.copyBuffer(c)}_addImportSection(){const e=new BufferReader,t=this._sectionOptions[SECTION_IMPORT].newEntries,i=VarUint32ToArray(t.length);e.copyBuffer(i);let r=0,n=0;for(let i=0;i<t.length;i++){const _=t[i],a=stringToByteArray(_.moduleStr),o=VarUint32ToArray(a.length),s=stringToByteArray(_.fieldStr),c=VarUint32ToArray(s.length),l=[_.kind];let O;if(_.kind==KIND_FUNC){if(_.type instanceof TypedWailVariable)O=_.type.value;else{if(_.type instanceof WailVariable)throw new Error("Untyped WailVariable in _addImportSection()");O=VarUint32ToArray(_.type)}_.variable instanceof WailVariable&&(_.variable.value=this._importFuncCount+r++)}else _.kind==KIND_GLOBAL&&(O=[_.type,_.mutability],_.variable instanceof WailVariable&&(_.variable.value=this._importGlobalCount+n++));e.copyBuffer(o),e.copyBuffer(a),e.copyBuffer(c),e.copyBuffer(s),e.copyBuffer(l),e.copyBuffer(O)}const _=e.write(),a=VarUint32ToArray(_.length);this.copyBuffer([SECTION_IMPORT]),this.copyBuffer(a),this.copyBuffer(_);const o=this._sectionOptions[SECTION_FUNCTION].pending;for(let e=0;e<o.length;e++){const t=o[e].oldIndex;o[e].variable.value=this._getAdjustedFunctionIndex(t)}const s=this._sectionOptions[SECTION_GLOBAL].pending;for(let e=0;e<s.length;e++){const t=s[e].oldIndex;s[e].variable.value=this._getAdjustedGlobalIndex(t)}}_parseImportSection(){this.commitBytes();const e=this.readVarUint32(),t=this.inPos,i=this.readVarUint32(),r=this.inPos-t,n=this.readBytes(e-r),_=new BufferReader(n),a=this._sectionOptions[SECTION_IMPORT].newEntries,o=this._sectionOptions[SECTION_IMPORT].existingEntries;for(let e=0;e<i;e++){_.commitBytes();let t=_.readVarUint32(),i=_.readBytes(t),r=_.readVarUint32(),n=_.readBytes(r);for(let _=0;_<o.length;_++){const a=o[_];e==a.index&&(void 0!==a.moduleStr&&(i=a.moduleStr,t=a.moduleStr.length),void 0!==a.fieldStr&&(n=a.fieldStr,r=a.fieldStr.length))}_.copyBuffer(VarUint32ToArray(t)),_.copyBuffer(i),_.copyBuffer(VarUint32ToArray(r)),_.copyBuffer(n);const a=_.readUint8();if(a==KIND_FUNC)this._importFuncCount++,_.readVarUint32();else if(a==KIND_TABLE){_.readUint8();const e=_.readUint8();_.readVarUint32(),e&&_.readVarUint32()}else if(a==KIND_MEMORY){const e=_.readUint8();_.readVarUint32(),e&&_.readVarUint32()}else{if(a!=KIND_GLOBAL)throw"Invalid type kind: "+a;this._importGlobalCount++,_.readUint8(),_.readUint8()}}let s=i,c=0,l=0;for(let e=0;e<a.length;e++,s++){_.commitBytes();const t=a[e],i=stringToByteArray(t.moduleStr),r=VarUint32ToArray(i.length),n=stringToByteArray(t.fieldStr),o=VarUint32ToArray(n.length),s=[t.kind];let O;if(t.kind==KIND_FUNC){if(t.type instanceof TypedWailVariable)O=t.type.value;else{if(t.type instanceof WailVariable)throw new Error("Untyped WailVariable in _addImportSection()");O=VarUint32ToArray(t.type)}t.variable instanceof WailVariable&&(t.variable.value=this._importFuncCount+c),c++}else t.kind==KIND_GLOBAL&&(O=[t.type,t.mutability],t.variable instanceof WailVariable&&(t.variable.value=this._importGlobalCount+l),l++);_.copyBuffer(r),_.copyBuffer(i),_.copyBuffer(o),_.copyBuffer(n),_.copyBuffer(s),_.copyBuffer(O)}const O=VarUint32ToArray(s),f=_.write(),I=VarUint32ToArray(O.length+f.length);this.copyBuffer(I),this.copyBuffer(O),this.copyBuffer(f),0==this._resolvedTables&&this._resolveTableIndices()}_addFunctionSection(){const e=new BufferReader,t=this._sectionOptions[SECTION_FUNCTION].newEntries,i=VarUint32ToArray(t.length);e.copyBuffer(i);for(let i=0;i<t.length;i++){let r,n=t[i];if(n.type instanceof TypedWailVariable)r=n.type.value;else{if(n.type instanceof WailVariable)throw new Error("Untyped WailVariable in _parseFunctionSection()");r=VarUint32ToArray(n.type)}if(e.copyBuffer(r),n.variable instanceof WailVariable){const e=newCount+this._importFuncCount;n.variable.value=this._getAdjustedFunctionIndex(e)}}const r=e.write(),n=VarUint32ToArray(r.length);this.copyBuffer([SECTION_FUNCTION]),this.copyBuffer(n),this.copyBuffer(r)}_parseFunctionSection(){this.commitBytes();const e=this._sectionOptions[SECTION_FUNCTION].newEntries,t=this._sectionOptions[SECTION_FUNCTION].existingEntries,i=this.readVarUint32(),r=this.inPos,n=this.readVarUint32(),_=this.inPos-r,a=this.readBytes(i-_),o=new BufferReader(a);for(let e=0;e<n;e++){o.commitBytes();let i=o.readVarUint32();for(let r=0;r<t.length;r++){const n=t[r];e==n.index&&(i=n.type)}o.copyBuffer(VarUint32ToArray(i))}let s=n;for(let t=0;t<e.length;t++,s++){let i,r=e[t];if(r.type instanceof TypedWailVariable)i=r.type.value;else{if(r.type instanceof WailVariable)throw new Error("Untyped WailVariable in _parseFunctionSection()");i=VarUint32ToArray(r.type)}if(o.copyBuffer(i),r.variable instanceof WailVariable){const e=s+this._importFuncCount;r.variable.value=this._getAdjustedFunctionIndex(e)}}const c=VarUint32ToArray(s),l=o.write(),O=VarUint32ToArray(c.length+l.length);this.copyBuffer(O),this.copyBuffer(c),this.copyBuffer(l)}_addGlobalSection(){const e=new BufferReader,t=this._sectionOptions[SECTION_GLOBAL].newEntries,i=VarUint32ToArray(t.length);e.copyBuffer(i);for(let i=0;i<t.length;i++){const r=t[i];e.copyBuffer(Uint8ToArray(r.globalType.contentType)),e.copyBuffer(Uint8ToArray(r.globalType.mutability));const n=this._expandArrayVariables(r.initExpr);e.copyBuffer(n),r.variable instanceof WailVariable&&(r.variable.value=this._importGlobalCount+i)}const r=e.write(),n=VarUint32ToArray(r.length);this.copyBuffer([SECTION_GLOBAL]),this.copyBuffer(n),this.copyBuffer(r)}_parseGlobalSection(){this.commitBytes();const e=this.readVarUint32(),t=this.inPos,i=this.readVarUint32(),r=this.inPos-t,n=this.readBytes(e-r),_=new BufferReader(n),a=this._sectionOptions[SECTION_GLOBAL].newEntries,o=this._sectionOptions[SECTION_GLOBAL].existingEntries,s=i+a.length;_.copyBuffer(VarUint32ToArray(s));for(let e=0;e<i;e++){let t,i;for(let r=0;r<o.length;r++){const n=o[r];let _=n.index;_ instanceof WailVariable&&(_=_.value),e==_&&(t=n.globalType.contentType,i=n.globalType.mutability)}_.readUint8();void 0!==t&&_.copyBuffer([t]),_.commitBytes();let r;_.readUint8();void 0!==i&&_.copyBuffer([i]);do{r=this._readInstruction(_)}while(r[0]!=OP_END);_.commitBytes()}for(let e=0;e<a.length;e++){const t=a[e];_.copyBuffer([t.globalType.contentType]),_.copyBuffer([t.globalType.mutability]),_.copyBuffer(this._expandArrayVariables(t.initExpr)),t.variable instanceof WailVariable&&(t.variable.value=this._importGlobalCount+i+e)}const c=_.write(),l=VarUint32ToArray(c.length);this.copyBuffer(l),this.copyBuffer(c)}_addExportSection(){const e=new BufferReader,t=this._sectionOptions[SECTION_EXPORT].newEntries,i=VarUint32ToArray(t.length);e.copyBuffer(i);for(let i=0;i<t.length;i++){const r=t[i],n=stringToByteArray(r.fieldStr),_=VarUint32ToArray(n.length),a=Uint8ToArray(r.kind);let o;if(r.index instanceof TypedWailVariable)o=r.index.value;else{if(r.index instanceof WailVariable)throw new Error("Untyped WailVariable in _parseExportSection()");o=VarUint32ToArray(r.index)}e.copyBuffer(_),e.copyBuffer(n),e.copyBuffer(a),e.copyBuffer(o)}const r=e.write(),n=VarUint32ToArray(r.length);this.copyBuffer([SECTION_EXPORT]),this.copyBuffer(n),this.copyBuffer(r)}_parseExportSection(){this.commitBytes();const e=this.readVarUint32(),t=this.readBytes(e),i=new BufferReader(t),r=i.readVarUint32(),n=this._sectionOptions[SECTION_EXPORT].newEntries,_=this._sectionOptions[SECTION_EXPORT].existingEntries,a=r+n.length;i.copyBuffer(VarUint32ToArray(a));for(let e=0;e<r;e++){i.commitBytes();let t=i.readVarUint32(),r=i.readBytes(t),n=i.readUint8(),a=i.readVarUint32();for(let i=0;i<_.length;i++){const o=_[i];e==o.index&&(void 0!==o.fieldStr&&(r=o.fieldStr,t=o.fieldStr.length),void 0!==o.kind&&(n=o.kind),void 0!==o.funcIndex&&(a=o.funcIndex))}let o=a;a instanceof WailVariable?o=a.value:n==KIND_FUNC?o=this._getAdjustedFunctionIndex(a):n==KIND_GLOBAL&&(o=this._getAdjustedGlobalIndex(a)),i.copyBuffer(VarUint32ToArray(t)),i.copyBuffer(r),i.copyBuffer([n]),i.copyBuffer(VarUint32ToArray(o))}for(let e=0;e<n.length;e++){const t=n[e],r=stringToByteArray(t.fieldStr),_=VarUint32ToArray(r.length),a=Uint8ToArray(t.kind);let o;if(t.index instanceof TypedWailVariable)o=t.index.value;else{if(t.index instanceof WailVariable)throw new Error("Untyped WailVariable in _parseExportSection()");o=VarUint32ToArray(t.index)}i.copyBuffer(_),i.copyBuffer(r),i.copyBuffer(a),i.copyBuffer(o)}const o=i.write(),s=VarUint32ToArray(o.length);this.copyBuffer(s),this.copyBuffer(o)}_parseStartSection(){this.commitBytes();this.readVarUint32();const e=this.readVarUint32(),t=this._sectionOptions[SECTION_START].existingEntries;let i;if(t.length>0)for(let e=0;e<t.length;e++){const r=t[e];if("number"==typeof r)i=r;else{if(!(r instanceof WailVariable))throw new Error("Invalid function index in _parseStartSection()");i=r.value}}else i=this._getAdjustedFunctionIndex(e);const r=VarUint32ToArray(i),n=VarUint32ToArray(r.length);this.copyBuffer(n),this.copyBuffer(r)}_addElementSection(){const e=new BufferReader,t=this._sectionOptions[SECTION_ELEMENT].newEntries,i=VarUint32ToArray(t.length);e.copyBuffer(i);for(let i=0;i<t.length;i++,newCount++){const r=t[i],n=r.index;if(0!=n)throw new Error("Unsupported element index "+n);const _=r.offset,a=this._expandArrayVariables(r.elems),o=a.length;e.copyBuffer(VarUint32ToArray(n)),e.copyBuffer(_),e.copyBuffer(VarUint32ToArray(o)),e.copyBuffer(a)}const r=e.write(),n=VarUint32ToArray(r.length);this.copyBuffer([SECTION_ELEMENT]),this.copyBuffer(n),this.copyBuffer(r)}_parseElementSection(){this.commitBytes();const e=this.readVarUint32(),t=this.inPos,i=this.readVarUint32(),r=this.inPos-t,n=this.readBytes(e-r),_=new BufferReader(n),a=this._sectionOptions[SECTION_ELEMENT].newEntries,o=this._sectionOptions[SECTION_ELEMENT].existingEntries;for(let e=0;e<i;e++){let t;_.readVarUint32();do{t=this._readInstruction(_)}while(t[0]!=OP_END);_.commitBytes();let i=_.readVarUint32(),r=[];for(let e=0;e<i;e++){const e=_.readVarUint32(),t=this._getAdjustedFunctionIndex(e);r.push(t)}for(let t=0;t<o.length;t++){const n=o[t];e==n.index&&void 0!==n.elems&&(i=(r=n.elems).length)}_.copyBuffer(VarUint32ToArray(i));for(let e=0;e<i;e++)_.copyBuffer(VarUint32ToArray(r[e]))}let s=i;for(let e=0;e<a.length;e++,s++){const t=a[e],i=t.index;if(0!=i)throw new Error("Unsupported element index "+i);const r=t.offset,n=this._expandArrayVariables(t.elems),o=n.length;_.copyBuffer(VarUint32ToArray(i)),_.copyBuffer(r),_.copyBuffer(VarUint32ToArray(o)),_.copyBuffer(n)}const c=_.write(),l=VarUint32ToArray(s),O=VarUint32ToArray(l.length+c.length);this.copyBuffer(O),this.copyBuffer(l),this.copyBuffer(c)}_addCodeSection(){const e=new BufferReader,t=this._sectionOptions[SECTION_CODE].newEntries,i=VarUint32ToArray(t.length);e.copyBuffer(i);const r=e.write(),n=VarUint32ToArray(r.length);this.copyBuffer([SECTION_CODE]),this.copyBuffer(n),this.copyBuffer(r)}_parseCodeSection(){this.commitBytes();const e=this.readVarUint32(),t=this.readBytes(e),i=new BufferReader(t),r=i.readVarUint32(),n=this._sectionOptions[SECTION_CODE].newEntries,_=r+n.length;i.copyBuffer(VarUint32ToArray(_));for(let e=0;e<r;e++){const t=this._getAdjustedFunctionIndex(this._importFuncCount+e);this._readFunction(i,t)}for(let e=r;e<_;e++){const t=this._funcSectionIndexToFuncTableIndex(e),r=new BufferReader;let _,a=!1;for(let e=0;e<n.length;e++){let i=(_=n[e]).index;if(i instanceof WailVariable&&(i=i.value),i==t){a=!0;break}}if(!a)throw new Error("No CODE entry found for index "+t);let o=_.locals,s=_.code;r.copyBuffer(VarUint32ToArray(o.length));for(let e=0;e<o.length;e++){const t=o[e];r.copyBuffer(VarUint32ToArray(1)),r.copyBuffer(Uint8ToArray(t))}s=this._expandArrayVariables(s),r.copyBuffer(s);const c=r.write(),l=VarUint32ToArray(c.length);i.copyBuffer(l),i.copyBuffer(c)}const a=i.write(),o=VarUint32ToArray(a.length);this.copyBuffer(o),this.copyBuffer(a)}_addDataSection(){const e=new BufferReader,t=this._sectionOptions[SECTION_DATA].newEntries,i=VarUint32ToArray(t.length);e.copyBuffer(i);for(let i=0;i<t.length;i++){const r=t[i];let n;n=void 0!==r.index?VarUint32ToArray(r.index):VarUint32ToArray(0);const _=r.offset;_[_.length-1]!=OP_END&&_.push(OP_END);const a=r.data,o=VarUint32ToArray(a.length);e.copyBuffer(n),e.copyBuffer(_),e.copyBuffer(o),e.copyBuffer(a)}const r=e.write(),n=VarUint32ToArray(r.length);this.copyBuffer([SECTION_DATA]),this.copyBuffer(n),this.copyBuffer(r)}_parseDataSection(){this.commitBytes();const e=this.readVarUint32(),t=this.inPos,i=this.readVarUint32(),r=this.inPos-t,n=this.readBytes(e-r),_=new BufferReader(n),a=this._sectionOptions[SECTION_DATA].newEntries,o=this._sectionOptions[SECTION_DATA].existingEntries,s=i+a.length;_.copyBuffer(VarUint32ToArray(s));for(let e=0;e<i;e++){let t;do{t=this._readInstruction(_)}while(t[0]!==OP_END);_.commitBytes();let i=_.readVarUint32(),r=_.readBytes(i);for(let t=0;t<o.length;t++){const n=o[t];e==n.index&&void 0!==n.data&&(i=(r=n.data).length)}_.copyBuffer(VarUint32ToArray(i)),_.copyBuffer(r)}for(let e=0;e<a.length;e++){const t=a[e];let i;i=void 0!==t.index?VarUint32ToArray(t.index):VarUint32ToArray(0);const r=t.offset;r[r.length-1]!=OP_END&&r.push(OP_END);const n=t.data,o=VarUint32ToArray(n.length);_.copyBuffer(i),_.copyBuffer(r),_.copyBuffer(o),_.copyBuffer(n)}const c=_.write(),l=VarUint32ToArray(c.length);this.copyBuffer(l),this.copyBuffer(c)}_readFunction(e,t){const i=this._sectionOptions[SECTION_CODE].existingEntries,r=e.readVarUint32(),n=e.readBytes(r),_=new BufferReader(n),a=_.readVarUint32();for(let e=0;e<a;e++)_.readVarUint32(),_.readUint8();_.commitBytes();const o=new BufferReader(n.subarray(_.inPos));for(;o.inPos<o.inBuffer.length;)this._readInstruction(o),o.commitBytes();let s=_.write(),c=o.write();if("function"==typeof this._globalFunctionCallback){const e={};e.bytes=o.write(),e.index=t;const i=this._globalFunctionCallback(e);!1!==i&&(c=i)}else for(let e=0;e<this._functionCallbacks.length;e++){const i=this._functionCallbacks[e];let r=i.index;if(r instanceof WailVariable&&(r=r.value),r===t){const e={};e.bytes=o.write(),e.index=t;const r=i.callback(e);!1!==r&&(c=r)}}for(let e=0;e<i.length;e++){const r=i[e];let n=r.index;if(n instanceof WailVariable&&(n=n.value),t==n){const e=new BufferReader,t=r.locals;e.copyBuffer(VarUint32ToArray(t.length));for(let i=0;i<t.length;i++){const r=t[i];e.copyBuffer(VarUint32ToArray(1)),e.copyBuffer(Uint8ToArray(r))}const i=this._expandArrayVariables(r.code);e.copyBuffer(i),c=e.write()}}let l=VarUint32ToArray(s.length+c.length);e.copyBuffer(l),e.copyBuffer(s),e.copyBuffer(c)}_readInstruction(e){e.commitBytes(),e.setAnchor();const t=e.readUint8();let i,r,n;switch(t){case OP_UNREACHABLE:case OP_NOP:case OP_ELSE:case OP_END:case OP_RETURN:case OP_DROP:case OP_SELECT:case OP_I32_EQZ:case OP_I32_EQ:case OP_I32_NE:case OP_I32_LT_S:case OP_I32_LT_U:case OP_I32_GT_S:case OP_I32_GT_U:case OP_I32_LE_S:case OP_I32_LE_U:case OP_I32_GE_S:case OP_I32_GE_U:case OP_I64_EQZ:case OP_I64_EQ:case OP_I64_NE:case OP_I64_LT_S:case OP_I64_LT_U:case OP_I64_GT_S:case OP_I64_GT_U:case OP_I64_LE_S:case OP_I64_LE_U:case OP_I64_GE_S:case OP_I64_GE_U:case OP_F32_EQ:case OP_F32_NE:case OP_F32_LT:case OP_F32_GT:case OP_F32_LE:case OP_F32_GE:case OP_F64_EQ:case OP_F64_NE:case OP_F64_LT:case OP_F64_GT:case OP_F64_LE:case OP_F64_GE:case OP_I32_CLZ:case OP_I32_CTZ:case OP_I32_POPCNT:case OP_I32_ADD:case OP_I32_SUB:case OP_I32_MUL:case OP_I32_DIV_S:case OP_I32_DIV_U:case OP_I32_REM_S:case OP_I32_REM_U:case OP_I32_AND:case OP_I32_OR:case OP_I32_XOR:case OP_I32_SHL:case OP_I32_SHR_S:case OP_I32_SHR_U:case OP_I32_ROTL:case OP_I32_ROTR:case OP_I64_CLZ:case OP_I64_CTZ:case OP_I64_POPCNT:case OP_I64_ADD:case OP_I64_SUB:case OP_I64_MUL:case OP_I64_DIV_S:case OP_I64_DIV_U:case OP_I64_REM_S:case OP_I64_REM_U:case OP_I64_AND:case OP_I64_OR:case OP_I64_XOR:case OP_I64_SHL:case OP_I64_SHR_S:case OP_I64_SHR_U:case OP_I64_ROTL:case OP_I64_ROTR:case OP_F32_ABS:case OP_F32_NEG:case OP_F32_CEIL:case OP_F32_FLOOR:case OP_F32_TRUNC:case OP_F32_NEAREST:case OP_F32_SQRT:case OP_F32_ADD:case OP_F32_SUB:case OP_F32_MUL:case OP_F32_DIV:case OP_F32_MIN:case OP_F32_MAX:case OP_F32_COPYSIGN:case OP_F64_ABS:case OP_F64_NEG:case OP_F64_CEIL:case OP_F64_FLOOR:case OP_F64_TRUNC:case OP_F64_NEAREST:case OP_F64_SQRT:case OP_F64_ADD:case OP_F64_SUB:case OP_F64_MUL:case OP_F64_DIV:case OP_F64_MIN:case OP_F64_MAX:case OP_F64_COPYSIGN:case OP_I32_WRAP_I64:case OP_I32_TRUNC_S_F32:case OP_I32_TRUNC_U_F32:case OP_I32_TRUNC_S_F64:case OP_I32_TRUNC_U_F64:case OP_I64_EXTEND_S_I32:case OP_I64_EXTEND_U_I32:case OP_I64_TRUNC_S_F32:case OP_I64_TRUNC_U_F32:case OP_I64_TRUNC_S_F64:case OP_I64_TRUNC_U_F64:case OP_F32_CONVERT_S_I32:case OP_F32_CONVERT_U_I32:case OP_F32_CONVERT_S_I64:case OP_F32_CONVERT_U_I64:case OP_F32_DEMOTE_F64:case OP_F64_CONVERT_S_I32:case OP_F64_CONVERT_U_I32:case OP_F64_CONVERT_S_I64:case OP_F64_CONVERT_U_I64:case OP_F64_PROMOTE_F32:case OP_I32_REINTERPRET_F32:case OP_I64_REINTERPRET_F64:case OP_F32_REINTERPRET_I32:case OP_F64_REINTERPRET_I64:break;case OP_BLOCK:case OP_LOOP:case OP_IF:case OP_MEMORY_SIZE:case OP_MEMORY_GROW:e.readUint8();break;case OP_BR:case OP_BR_IF:case OP_GET_LOCAL:case OP_SET_LOCAL:case OP_TEE_LOCAL:case OP_I32_CONST:case OP_I64_CONST:e.readVarUint32();break;case OP_GET_GLOBAL:case OP_SET_GLOBAL:e.commitBytes(),i=e.readVarUint32(),r=this._getAdjustedGlobalIndex(i),e.copyBuffer(VarUint32ToArray(r));break;case OP_F32_CONST:e.readBytes(4);break;case OP_F64_CONST:e.readBytes(8);break;case OP_I32_LOAD:case OP_I64_LOAD:case OP_F32_LOAD:case OP_F64_LOAD:case OP_I32_LOAD8_S:case OP_I32_LOAD8_U:case OP_I32_LOAD16_S:case OP_I32_LOAD16_U:case OP_I64_LOAD8_S:case OP_I64_LOAD8_U:case OP_I64_LOAD16_S:case OP_I64_LOAD16_U:case OP_I64_LOAD32_S:case OP_I64_LOAD32_U:case OP_I32_STORE:case OP_I64_STORE:case OP_F32_STORE:case OP_F64_STORE:case OP_I32_STORE8:case OP_I32_STORE16:case OP_I64_STORE8:case OP_I64_STORE16:case OP_I64_STORE32:e.readVarUint32(),e.readVarUint32();break;case OP_BR_TABLE:const _=e.readVarUint32();for(let t=0;t<_;t++)e.readVarUint32();e.readVarUint32();break;case OP_CALL:e.commitBytes(),i=e.readVarUint32(),r=this._getAdjustedFunctionIndex(i),e.copyBuffer(VarUint32ToArray(r));break;case OP_CALL_INDIRECT:e.readVarUint32(),e.readUint8();break;case OP_I32_EXTEND8_S:case OP_I32_EXTEND16_S:case OP_I64_EXTEND8_S:case OP_I64_EXTEND16_S:case OP_I64_EXTEND32_S:break;case OP_BULK_MEMORY:switch(n=e.readUint8()){case ARG_MEMORY_INIT:case ARG_TABLE_INIT:e.readVarUint32(),e.readUint8();break;case ARG_DATA_DROP:case ARG_ELEM_DROP:e.readVarUint32();break;case ARG_MEMORY_COPY:case ARG_TABLE_COPY:e.readUint8(),e.readUint8();break;case ARG_MEMORY_FILL:e.readUint8()}break;case OP_ATOMIC:if((n=e.readUint8())>ARG_I64_ATOMIC_RMW_CMPXCHG_32U||n>2&&n<16)throw new Error("Unknown argument '"+n+"' for OP_ATOMIC. Probably parsing incorrectly");e.readVarUint32(),e.readVarUint32();break;default:throw new Error("Unknown opcode '"+t+"'. Probably parsing incorrectly")}if(e.commitBytes(),void 0!==this._instructionCallbacks[t]){const i=e.readFromAnchor(),r=this._instructionCallbacks[t](i);e.writeAtAnchor(r)}else if("function"==typeof this._globalInstructionCallback){const i=e.readFromAnchor(),r=this._globalInstructionCallback[t](i);e.writeAtAnchor(r)}return e.readFromAnchor()}_funcSectionIndexToFuncTableIndex(e){return e+this._importFuncCount+this._importFuncNewCount}_getAdjustedFunctionIndex(e){return e>=this._importFuncCount?e+this._importFuncNewCount:e}_getAdjustedGlobalIndex(e){return e>=this._importGlobalCount?e+this._importGlobalNewCount:e}}
