const SECTION_CUSTOM=0,SECTION_TYPE=1,SECTION_IMPORT=2,SECTION_FUNCTION=3,SECTION_TABLE=4,SECTION_MEMORY=5,SECTION_GLOBAL=6,SECTION_EXPORT=7,SECTION_START=8,SECTION_ELEMENT=9,SECTION_CODE=10,SECTION_DATA=11,MAX_SECTION_ID=11,KIND_FUNC=0,KIND_TABLE=1,KIND_MEMORY=2,KIND_GLOBAL=3,kindStr={func:KIND_FUNC,table:KIND_TABLE,memory:KIND_MEMORY,global:KIND_GLOBAL},convertKind=function(e){const t=kindStr[e];if(void 0===t)throw new Error("Invalid kind "+e);return t},VALUE_TYPE_I32=127,VALUE_TYPE_I64=126,VALUE_TYPE_F32=125,VALUE_TYPE_F64=124,VALUE_TYPE_ANYFUNC=112,VALUE_TYPE_FUNC=96,VALUE_TYPE_BLOCK=64,valueTypeStr={i32:127,i64:126,f32:125,f64:124,anyfunc:112,func:96,block:64},convertValueType=function(e){const t=valueTypeStr[e];if(void 0===t)throw new Error("Invalid value type "+e);return t},OP_UNREACHABLE=0,OP_NOP=1,OP_BLOCK=2,OP_LOOP=3,OP_IF=4,OP_ELSE=5,OP_END=11,OP_BR=12,OP_BR_IF=13,OP_BR_TABLE=14,OP_RETURN=15,OP_CALL=16,OP_CALL_INDIRECT=17,OP_DROP=26,OP_SELECT=27,OP_GET_LOCAL=32,OP_SET_LOCAL=33,OP_TEE_LOCAL=34,OP_GET_GLOBAL=35,OP_SET_GLOBAL=36,OP_I32_LOAD=40,OP_I64_LOAD=41,OP_F32_LOAD=42,OP_F64_LOAD=43,OP_I32_LOAD8_S=44,OP_I32_LOAD8_U=45,OP_I32_LOAD16_S=46,OP_I32_LOAD16_U=47,OP_I64_LOAD8_S=48,OP_I64_LOAD8_U=49,OP_I64_LOAD16_S=50,OP_I64_LOAD16_U=51,OP_I64_LOAD32_S=52,OP_I64_LOAD32_U=53,OP_I32_STORE=54,OP_I64_STORE=55,OP_F32_STORE=56,OP_F64_STORE=57,OP_I32_STORE8=58,OP_I32_STORE16=59,OP_I64_STORE8=60,OP_I64_STORE16=61,OP_I64_STORE32=62,OP_MEMORY_SIZE=63,OP_MEMORY_GROW=64,OP_I32_CONST=65,OP_I64_CONST=66,OP_F32_CONST=67,OP_F64_CONST=68,OP_I32_EQZ=69,OP_I32_EQ=70,OP_I32_NE=71,OP_I32_LT_S=72,OP_I32_LT_U=73,OP_I32_GT_S=74,OP_I32_GT_U=75,OP_I32_LE_S=76,OP_I32_LE_U=77,OP_I32_GE_S=78,OP_I32_GE_U=79,OP_I64_EQZ=80,OP_I64_EQ=81,OP_I64_NE=82,OP_I64_LT_S=83,OP_I64_LT_U=84,OP_I64_GT_S=85,OP_I64_GT_U=86,OP_I64_LE_S=87,OP_I64_LE_U=88,OP_I64_GE_S=89,OP_I64_GE_U=90,OP_F32_EQ=91,OP_F32_NE=92,OP_F32_LT=93,OP_F32_GT=94,OP_F32_LE=95,OP_F32_GE=96,OP_F64_EQ=97,OP_F64_NE=98,OP_F64_LT=99,OP_F64_GT=100,OP_F64_LE=101,OP_F64_GE=102,OP_I32_CLZ=103,OP_I32_CTZ=104,OP_I32_POPCNT=105,OP_I32_ADD=106,OP_I32_SUB=107,OP_I32_MUL=108,OP_I32_DIV_S=109,OP_I32_DIV_U=110,OP_I32_REM_S=111,OP_I32_REM_U=112,OP_I32_AND=113,OP_I32_OR=114,OP_I32_XOR=115,OP_I32_SHL=116,OP_I32_SHR_S=117,OP_I32_SHR_U=118,OP_I32_ROTL=119,OP_I32_ROTR=120,OP_I64_CLZ=121,OP_I64_CTZ=122,OP_I64_POPCNT=123,OP_I64_ADD=124,OP_I64_SUB=125,OP_I64_MUL=126,OP_I64_DIV_S=127,OP_I64_DIV_U=128,OP_I64_REM_S=129,OP_I64_REM_U=130,OP_I64_AND=131,OP_I64_OR=132,OP_I64_XOR=133,OP_I64_SHL=134,OP_I64_SHR_S=135,OP_I64_SHR_U=136,OP_I64_ROTL=137,OP_I64_ROTR=138,OP_F32_ABS=139,OP_F32_NEG=140,OP_F32_CEIL=141,OP_F32_FLOOR=142,OP_F32_TRUNC=143,OP_F32_NEAREST=144,OP_F32_SQRT=145,OP_F32_ADD=146,OP_F32_SUB=147,OP_F32_MUL=148,OP_F32_DIV=149,OP_F32_MIN=150,OP_F32_MAX=151,OP_F32_COPYSIGN=152,OP_F64_ABS=153,OP_F64_NEG=154,OP_F64_CEIL=155,OP_F64_FLOOR=156,OP_F64_TRUNC=157,OP_F64_NEAREST=158,OP_F64_SQRT=159,OP_F64_ADD=160,OP_F64_SUB=161,OP_F64_MUL=162,OP_F64_DIV=163,OP_F64_MIN=164,OP_F64_MAX=165,OP_F64_COPYSIGN=166,OP_I32_WRAP_I64=167,OP_I32_TRUNC_S_F32=168,OP_I32_TRUNC_U_F32=169,OP_I32_TRUNC_S_F64=170,OP_I32_TRUNC_U_F64=171,OP_I64_EXTEND_S_I32=172,OP_I64_EXTEND_U_I32=173,OP_I64_TRUNC_S_F32=174,OP_I64_TRUNC_U_F32=175,OP_I64_TRUNC_S_F64=176,OP_I64_TRUNC_U_F64=177,OP_F32_CONVERT_S_I32=178,OP_F32_CONVERT_U_I32=179,OP_F32_CONVERT_S_I64=180,OP_F32_CONVERT_U_I64=181,OP_F32_DEMOTE_F64=182,OP_F64_CONVERT_S_I32=183,OP_F64_CONVERT_U_I32=184,OP_F64_CONVERT_S_I64=185,OP_F64_CONVERT_U_I64=186,OP_F64_PROMOTE_F32=187,OP_I32_REINTERPRET_F32=188,OP_I64_REINTERPRET_F64=189,OP_F32_REINTERPRET_I32=190,OP_F64_REINTERPRET_I64=191,convertOpcode=function(e){const t=opcodeStr[e];if(void 0===t)throw new Error("Invalid opcode "+e);return t},convertOpcodeArray=function(e){const t=[];for(let i=0;i<e.length;i++){const r=e[i];let n=r;"string"==typeof r&&(n=convertOpcode(r)),t.push(n)}return t},Uint8ToArray=function(e){return[255&e]},Uint32ToArray=function(e){return[255&e,(65280&e)>>8,(16711680&e)>>16,(4278190080&e)>>24]},Uint64ToArray=function(e){return[255&e,(65280&e)>>8,(16711680&e)>>16,(4278190080&e)>>24,(0xff00000000&e)>>32,(0xff0000000000&e)>>40,(0xff000000000000&e)>>48,(0xff00000000000000&e)>>56]},VarUint32ToArray=function(e){const t=[];let i=e;if(0==e)return[0];for(;i>0;){let e=127&i;(i>>=7)&&(e|=128),t.push(e)}return t},VarSint32ToArray=function(e){const t=[];let i=e;for(;;){if(thisByte=127&i,-1==(i>>=7)&&64&thisByte){t.push(thisByte);break}if(!(0!=i||64&thisByte)){t.push(thisByte);break}thisByte|=128,t.push(thisByte)}return t},stringToByteArray=function(e){return e.split("").map(function(e){return e.charCodeAt(0)})},VarUint32=function(e){return"number"==typeof e?VarUint32ToArray(e):e instanceof WailVariable?e.varUint32():void 0};class WailVariable{constructor(){this._value=null}get value(){if(null===this._value)throw new Error("Attempted to resolve WailVariable before set");return this._value}set value(e){this._value=e}i32(){return null!==this._value?this.value:new WailI32(this)}f32(){if(null!==this._value){const e=new Float32Array([this._value]);return new Uint8Array(e.buffer)}return new WailF32(this)}i64(){return null!==this._value?this.value:new WailI64(this)}f64(){if(null!==this._value){const e=new Float64Array([this._value]);return new Uint8Array(e.buffer)}return new WailF64(this)}varUint32(){return null!==this._value?VarUint32(this.value):new WailVarUint32(this)}}class TypedWailVariable{constructor(e){this._parent=e}}class WailI32 extends TypedWailVariable{get value(){return Uint32ToArray(this._parent.value)}}class WailF32 extends TypedWailVariable{get value(){return Uint32ToArray(this._parent.value)}}class WailI64 extends TypedWailVariable{get value(){return Uint64ToArray(this._parent.value)}}class WailF64 extends TypedWailVariable{get value(){return Uint64ToArray(this._parent.value)}}class WailVarUint32 extends TypedWailVariable{get value(){return VarUint32ToArray(this._parent.value)}}const BufferReader=class{constructor(e){this.inBuffer=null,this.outBuffer=null,void 0!==e?(this.inBuffer=new Uint8Array(e),this.outBuffer=new Uint8Array(2*e.length)):this.outBuffer=new Uint8Array(1),this.inPos=0,this._copyPos=0,this.outPos=0,this._anchor=null}load(e){this.inBuffer=new Uint8Array(e),this.outBuffer=new Uint8Array(2*this.inBuffer.length)}resize(){if(0==this.outBuffer.length)throw new Error("Attempted to resize 0-length buffer");const e=new Uint8Array(Math.ceil(1.25*this.outBuffer.length));for(let t=0;t<this.outPos;t++)e[t]=this.outBuffer[t];this.outBuffer=e}readUint8(){return this.inBuffer[this.inPos++]}readUint32(){return this.inBuffer[this.inPos++]|this.inBuffer[this.inPos++]<<8|this.inBuffer[this.inPos++]<<16|this.inBuffer[this.inPos++]<<24}readVarUint32(){let e,t=0,i=0;do{t|=(127&(e=this.readUint8()))<<i,i+=7}while(128&e);return t}readUint64(){return this.inBuffer[this.inPos++]|this.inBuffer[this.inPos++]<<8|this.inBuffer[this.inPos++]<<16|this.inBuffer[this.inPos++]<<24|this.inBuffer[this.inPos++]<<32|this.inBuffer[this.inPos++]<<40|this.inBuffer[this.inPos++]<<48|this.inBuffer[this.inPos++]<<56}readBytes(e){const t=new Uint8Array(e);for(let i=0;i<e;i++)t[i]=this.inBuffer[this.inPos++];return t}copyBuffer(e){for(;e.length+this.outPos>this.outBuffer.length;)this.resize();for(let t=0;t<e.length;t++,this.outPos++)this.outBuffer[this.outPos]=e[t];this.updateCopyPosition()}commitBytes(){for(;this.inPos-this._copyPos+this.outPos>this.outBuffer.length;)this.resize();for(;this._copyPos<this.inPos;this._copyPos++,this.outPos++)this.outBuffer[this.outPos]=this.inBuffer[this._copyPos]}updateCopyPosition(){this._copyPos=this.inPos}setAnchor(){this._anchor=this.outPos}readFromAnchor(){return this.outBuffer.slice(this._anchor,this.outPos)}writeAtAnchor(e){for(;e.length+this.outPos>this.outBuffer.length;)this.resize();for(let t=0;t<e.length;t++)this.outBuffer[this._anchor+t]=e[t];this.outPos=this._anchor+e.length}write(){return this.outBuffer.slice(0,this.outPos)}};class WailParser extends BufferReader{constructor(e){super(e),this._finished=!1,this._newSections=[],this._removeSectionIds=[],this._resolvedTables=!1,this._importFuncCount=0,this._importFuncNewCount=0,this._importGlobalCount=0,this._importGlobalNewCount=0,this._globalFunctionCallback=null,this._functionCallbacks=[],this._globalInstructionCallback=null,this._instructionCallbacks={},this._sectionOptions={};for(let e=0;e<=MAX_SECTION_ID;e++)this._sectionOptions[e]={newEntries:[],existingEntries:[],pending:[]};this._requiredSectionFlags=0,this._optionalSectionFlags=0,this._parsedSections=0,this.__variables=[]}parse(){const e=this.readUint32();this.readUint32();if(1836278016!=e)throw new Error("Invalid magic. Probably not a WebAssembly binary");for(;this.inPos<this.inBuffer.length;)this._readSection();this.commitBytes(),this._finished=!0}removeSection(e){if("number"!=typeof e)throw new Error("Invalid argument to removeSection()");this._removeSectionIds.push(e)}addTypeEntry(e){const t={},i=e.form;t.form="number"==typeof i?i:convertValueType(i);const r=e.params;if(r instanceof Array){const e=[];for(let t=0;t<r.length;t++){const i=r[t];"number"==typeof i?e.push(i):e.push(convertValueType(i))}t.params=e}else t.params=[];const n=e.returnType;"number"==typeof n?t.returnType=n:"string"==typeof n&&(t.returnType=convertValueType(n));const a=this._createVariable();return t.variable=a,this._sectionOptions[SECTION_TYPE].newEntries.push(t),this._requiredSectionFlags|=1<<SECTION_TYPE,a}editTypeEntry(e,t){const i={};if("number"!=typeof e)throw new Error("Invalid index in editTypeEntry()");i.index=e;const r=t.params;r instanceof Array?i.params=r:i.params=[];const n=t.returnType;n&&(i.returnType=n),this._sectionOptions[SECTION_TYPE].existingEntries.push(i),this._optionalSectionFlags|=1<<SECTION_TYPE}addImportEntry(e){const t={},i=e.moduleStr;if(!("string"==typeof i||i instanceof String))throw new Error("Invalid moduleStr");t.moduleStr=i;const r=e.fieldStr;if(!("string"==typeof r||r instanceof String))throw new Error("Invalid fieldStr");t.fieldStr=r;const n=e.kind;let a;a="number"==typeof n?n:convertKind(n);let o=e.type;switch(t.kind=a,a){case KIND_FUNC:if(this._importFuncNewCount++,"number"==typeof o)t.type=o;else if(o instanceof WailVarUint32)t.type=o;else{if(!(o instanceof WailVariable))throw new Error("Invalid type");t.type=o.varUint32()}break;case KIND_GLOBAL:if(this._importGlobalNewCount++,"number"!=typeof o)throw new Error("Invalid type");if(t.type=o,0!==e.mutability&&1!==e.mutability&&!0!==e.mutability&&!1!==e.mutability)throw new Error("Invalid mutability");t.mutability=e.mutability;break;case KIND_MEMORY:throw new Error("Adding new memory object not currently supported");case KIND_TABLE:throw new Error("Adding new table object not currently supported");default:throw new Error("Invalid kind")}const s=this._createVariable();return t.variable=s,this._sectionOptions[SECTION_IMPORT].newEntries.push(t),this._requiredSectionFlags|=1<<SECTION_IMPORT,this._importFuncNewCount>0&&(this._optionalSectionFlags|=1<<SECTION_EXPORT,this._optionalSectionFlags|=1<<SECTION_ELEMENT,this._optionalSectionFlags|=1<<SECTION_CODE,this._optionalSectionFlags|=1<<SECTION_START),this._importGlobalNewCount>0&&(this._optionalSectionFlags|=1<<SECTION_EXPORT,this._optionalSectionFlags|=1<<SECTION_CODE),s}editImportEntry(e,t){const i={};if(i.index=e,"number"!=typeof e&&!(e instanceof WailVariable))throw new Error("Invalid index in editImportEntry()");const r=t.moduleStr;("string"==typeof r||r instanceof String)&&(i.moduleStr=stringToByteArray(r));const n=t.fieldStr;("string"==typeof n||n instanceof String)&&(i.fieldStr=stringToByteArray(n)),this._sectionOptions[SECTION_IMPORT].existingEntries.push(i),this._optionalSectionFlags|=1<<SECTION_IMPORT}addFunctionEntry(e){const t={},i=e.type;if("number"==typeof i)t.type=i;else if(i instanceof WailVarUint32)t.type=i;else{if(!(i instanceof WailVariable))throw new Error("Invalid type");t.type=i.varUint32()}const r=this._createVariable();return t.variable=r,this._sectionOptions[SECTION_FUNCTION].newEntries.push(t),this._requiredSectionFlags|=1<<SECTION_FUNCTION,r}editFunctionEntry(e,t){const i={};if(i.index=e,"number"!=typeof e&&!(e instanceof WailVariable))throw new Error("Invalid index in editFunctionEntry()");const r=t.type;if("number"!=typeof r)throw new Error("Invalid type in editFunctionEntry()");i.type=r,this._sectionOptions[SECTION_FUNCTION].existingEntries.push(i),this._optionalSectionFlags|=1<<SECTION_FUNCTION}getFunctionIndex(e){if(this._finished){if(e instanceof WailVariable)return e;{const t=this._createVariable;return t.value=this._getAdjustedFunctionIndex(e),t}}const t=this._createVariable();if("number"!=typeof e)throw new Error("Invalid index in getFunctionIndex()");const i={oldIndex:e,variable:t};return this._sectionOptions[SECTION_FUNCTION].pending.push(i),this._optionalSectionFlags|=1<<SECTION_IMPORT,t}addGlobalEntry(e){const t={globalType:{}};if(void 0===e.globalType)throw new Error("Invalid globalType");"number"==typeof e.globalType.contentType?t.globalType.contentType=e.globalType.contentType:t.globalType.contentType=convertValueType(e.globalType.contentType);const i=e.globalType.mutability;if(1==i)t.globalType.mutability=1;else{if(0!=i)throw new Error("Invalid mutability");t.globalType.mutability=0}e.initExpr instanceof Array?t.initExpr=convertOpcodeArray(e.initExpr):t.initExpr=[OP_I32_CONST,VarUint32(0),OP_END];const r=this._createVariable();return t.variable=r,this._sectionOptions[SECTION_GLOBAL].newEntries.push(t),this._requiredSectionFlags|=1<<SECTION_GLOBAL,r}editGlobalEntry(e,t){const i={};if("number"==typeof e)console.warn("Using raw indexes in editGlobalEntry() can have unpredictable results. Consider using getGlobalIndex() instead");else if(!(e instanceof WailVariable))throw new Error("Invalid globalIndex in addCodeEntry()");if(i.index=e,i.globalType={},void 0===t.globalType)throw new Error("Invalid globalType");"number"==typeof t.globalType.contentType?i.globalType.contentType=t.globalType.contentType:i.globalType.contentType=convertValueType(t.globalType.contentType);const r=t.globalType.mutability;if(1==r)i.globalType.mutability=1;else{if(0!=r)throw new Error("Invalid mutability");i.globalType.mutability=0}this._sectionOptions[SECTION_GLOBAL].existingEntries.push(i),this._requiredSectionFlags|=1<<SECTION_GLOBAL}getGlobalIndex(e){if(this._finished)return e instanceof WailVariable?e.value:this._getAdjustedGlobalIndex(e);const t=this._createVariable();if("number"!=typeof e)throw new Error("Invalid index in getGlobalIndex()");const i={oldIndex:e,variable:t};return this._sectionOptions[SECTION_GLOBAL].pending.push(i),this._optionalSectionFlags|=1<<SECTION_IMPORT,t}addExportEntry(e,t){const i={};if(!("string"==typeof t.fieldStr||t.fieldStr instanceof String))throw new Error("Invalid fieldStr");if(i.fieldStr=t.fieldStr,"number"==typeof t.kind?i.kind=t.kind:i.kind=convertKind(t.kind),"number"==typeof e)i.index=e;else if(e instanceof WailVarUint32)i.index=e;else{if(!(e instanceof WailVariable))throw new Error("Invalid type");i.index=e.varUint32()}const r=this._createVariable();return i.variable=r,this._sectionOptions[SECTION_EXPORT].newEntries.push(i),this._requiredSectionFlags|=1<<SECTION_EXPORT,r}editExportEntry(e,t){const i={};if(i.index=e,"number"!=typeof e&&!(e instanceof WailVariable))throw new Error("Invalid index in editExportEntry()");const r=t.fieldStr;("string"==typeof r||r instanceof String)&&(i.fieldStr=stringToByteArray(r)),i.kind=t.kind,i.funcIndex=t.index,this._sectionOptions[SECTION_EXPORT].existingEntries.push(i),this._optionalSectionFlags|=1<<SECTION_EXPORT}editStartEntry(e){if("number"!=typeof e&&!(e instanceof WailVariable))throw new Error("Invalid index in editStartEntry()");this._sectionOptions[SECTION_START].existingEntries.push(e),this._requiredSectionFlags|=1<<SECTION_START}addElementEntry(e){const t=this._createVariable();return e.variable=t,this._sectionOptions[SECTION_ELEMENT].newEntries.push(e),this._requiredSectionFlags|=1<<SECTION_ELEMENT,t}editElementEntry(e,t){const i={};if(i.index=e,"number"!=typeof e&&!(e instanceof WailVariable))throw new Error("Invalid index in editElementEntry()");i.elems=[],this._sectionOptions[SECTION_ELEMENT].existingEntries.push(i),this._optionalSectionFlags|=1<<SECTION_ELEMENT}addCodeEntry(e,t){const i={};if("number"==typeof e)console.warn("Using raw indexes in addCodeEntry() can have unpredictable results. Consider using getFunctionIndex() instead");else if(!(e instanceof WailVariable))throw new Error("Invalid funcIndex in addCodeEntry()");i.index=e;const r=t.locals;if(r instanceof Array){const e=[];for(let t=0;t<r.length;t++){const i=r[t];if("number"==typeof i)e.push(i);else{if("string"!=typeof i)throw new Error("Invalid local entry in addCodeEntry()");e.push(convertValueType(i))}}i.locals=e}else i.locals=[];const n=t.code;if(!(n instanceof Array))throw new Error("Invalid code");i.code=convertOpcodeArray(n);const a=this._createVariable();return i.variable=a,this._sectionOptions[SECTION_CODE].newEntries.push(i),this._requiredSectionFlags|=1<<SECTION_CODE,a}editCodeEntry(e,t){const i={};if("number"==typeof e)console.warn("Using raw indexes in editCodeEntry() can have unpredictable results. Consider using getFunctionIndex() instead");else if(!(e instanceof WailVariable))throw new Error("Invalid funcIndex in addCodeEntry()");i.index=e;const r=t.locals;if(r instanceof Array){const e=[];for(let t=0;t<r.length;t++){const i=r[t];if("number"==typeof i)e.push(i);else{if("string"!=typeof i)throw new Error("Invalid local entry in addCodeEntry()");e.push(convertValueType(i))}}i.locals=e}else i.locals=[];const n=t.code;if(!(n instanceof Array))throw new Error("Invalid code");i.code=convertOpcodeArray(n),this._sectionOptions[SECTION_CODE].existingEntries.push(i),this._optionalSectionFlags|=1<<SECTION_IMPORT,this._optionalSectionFlags|=1<<SECTION_CODE}addDataEntry(e){const t=this._createVariable();return e.variable=t,this._sectionOptions[SECTION_DATA].newEntries.push(e),this._requiredSectionFlags|=1<<SECTION_DATA,t}editDataEntry(e,t){const i={};if("number"!=typeof e)throw new Error("Invalid index in editTypeEntry()");i.index=e,"string"==typeof t.data?i.data=stringToByteArray(t.data):i.data=t.data,this._sectionOptions[SECTION_DATA].existingEntries.push(i),this._optionalSectionFlags|=1<<SECTION_DATA}addCodeElementParser(e,t){if("function"!=typeof t)throw new Error("Bad callback in addCodeElementParser()");if(null===e)this._globalFunctionCallback=t;else{if(!("number"==typeof e||e instanceof WailVariable))throw new Error("Bad id "+e+" in addCodeElementParser()");{const i={};i.index=e,i.callback=t,this._functionCallbacks.push(i)}}this._optionalSectionFlags|=1<<SECTION_IMPORT,this._optionalSectionFlags|=1<<SECTION_CODE}addInstructionParser(e,t){if("function"!=typeof t)throw new Error("Bad callback in addInstructionParser()");if(null===e)this._globalInstructionCallback=t;else{if(isNaN(e)&&!(e instanceof WailVariable))throw new Error("Bad opcode "+e+" in addCodeElementParser()");this._instructionCallbacks[e]=t}this._optionalSectionFlags|=1<<SECTION_CODE}addRawSection(e,t){const i={};if("number"!=typeof e)throw new Error("Bad section index "+index+" in addRawSection()");i.id=e,i.bytes=t,this._newSections.push(i)}_createVariable(){const e=this.__variables.length,t=new WailVariable(this,e);return this.__variables.push(t),t}_getVariable(e){return this.__variables[e]}_setVariable(e,t){this.__variables[e]=t}_expandArrayVariables(e){for(let t=0;t<e.length;t++){const i=e[t];if(i instanceof Array)e.splice(t,1),e.splice(t,0,...i);else if(i instanceof TypedWailVariable){const r=i;e.splice(t,1),e.splice(t,0,...r.value)}else if(i instanceof WailVariable)throw new Error("Untyped WailVariable in _expandArrayVariables()")}return e}_readSection(){this.commitBytes();const e=this.readUint8();if(e>MAX_SECTION_ID)throw new Error("Illegal section ID "+e+". Probably parsing incorrectly");let t;if(this._removeSectionIds.includes(e))return t=this.readVarUint32(),this.readBytes(t),void this.updateCopyPosition();let i=!1;(this._requiredSectionFlags&1<<e||this._optionalSectionFlags&1<<e)&&(i=!0);for(let t=0;t<e;t++){const i=1<<t,r=this._requiredSectionFlags&i;if(r&&!(r&this._parsedSections)){switch(t){case SECTION_TYPE:this._addTypeSection();break;case SECTION_IMPORT:this._addImportSection();break;case SECTION_FUNCTION:this._addFunctionSection();break;case SECTION_GLOBAL:this._addGlobalSection();break;case SECTION_EXPORT:this._addExportSection();break;case SECTION_START:this._addStartSection();break;case SECTION_ELEMENT:this._addElementSection();break;case SECTION_CODE:this._addCodeSection();break;case SECTION_DATA:this._addDataSection();break;default:throw new Error("Attempted to add unhandled section")}this._parsedSections|=i,this.copyBuffer([e])}}for(let t=0;t<this._newSections.length;t++){const i=this._newSections[t];if(e>i.id){const e=i.bytes,t=VarUint32ToArray(e.length);this.copyBuffer([i.id]),this.copyBuffer(t),this.copyBuffer(e)}}if(!i)return t=this.readVarUint32(),void this.readBytes(t);switch(e>SECTION_IMPORT&&0==this._resolvedTables&&this._resolveTableIndices(),e){case SECTION_TYPE:this._parseTypeSection();break;case SECTION_IMPORT:this._parseImportSection();break;case SECTION_FUNCTION:this._parseFunctionSection();break;case SECTION_GLOBAL:this._parseGlobalSection();break;case SECTION_EXPORT:this._parseExportSection();break;case SECTION_START:this._parseStartSection();break;case SECTION_ELEMENT:this._parseElementSection();break;case SECTION_CODE:this._parseCodeSection();break;case SECTION_DATA:this._parseDataSection();break;default:throw new Error("Attempted to parse unhandled section")}this._parsedSections|=1<<e}_resolveTableIndices(){const e=this._sectionOptions[SECTION_FUNCTION].pending;for(let t=0;t<e.length;t++){const i=e[t].oldIndex;e[t].variable.value=this._getAdjustedFunctionIndex(i)}const t=this._sectionOptions[SECTION_GLOBAL].pending;for(let e=0;e<t.length;e++){const i=t[e].oldIndex;t[e].variable.value=this._getAdjustedGlobalIndex(i)}this._resolvedTables=!0}_addTypeSection(){const e=new BufferReader,t=this._sectionOptions[SECTION_TYPE].newEntries,i=VarUint32ToArray(t.length);e.copyBuffer(i);for(let i=0;i<t.length;i++){const r=t[i],n=r.form,a=r.params;let o=null;void 0!==r.returnType&&(o=r.returnType),r.variable instanceof WailVariable&&(r.variable.value=oldCount+i),e.copyBuffer(Uint8ToArray(n)),e.copyBuffer(VarUint32ToArray(a.length)),e.copyBuffer(a),null!==o?(e.copyBuffer(Uint8ToArray(1)),e.copyBuffer(Uint8ToArray(o))):e.copyBuffer(Uint8ToArray(0))}const r=e.write(),n=VarUint32ToArray(r.length);this.copyBuffer([SECTION_TYPE]),this.copyBuffer(n),this.copyBuffer(r)}_parseTypeSection(){this.commitBytes();const e=this.readVarUint32(),t=this.inPos,i=this.readVarUint32(),r=this.inPos-t,n=this.readBytes(e-r),a=new BufferReader(n),o=this._sectionOptions[SECTION_TYPE].newEntries,s=this._sectionOptions[SECTION_TYPE].existingEntries,_=i+o.length;a.copyBuffer(VarUint32ToArray(_));for(let e=0;e<i;e++){const t=a.readUint8();let i=a.readVarUint32(),r=[];for(let e=0;e<i;e++)r.push(a.readUint8());let n=a.readUint8(),o=null;if(1==n)o=a.readUint8();else if(0!=n)throw new Error("Invalid returnCount");for(let t=0;t<s.length;t++){const i=s[t];e==i.index&&(void 0!==i.params&&(r=mod.params),void 0!==i.returnType&&(n=1,o=mod.returnType))}a.copyBuffer(Uint8ToArray(t)),a.copyBuffer(VarUint32ToArray(r.length)),a.copyBuffer(r),n?(a.copyBuffer(Uint8ToArray(1)),a.copyBuffer(Uint8ToArray(o))):a.copyBuffer(Uint8ToArray(0))}for(let e=0;e<o.length;e++){const t=o[e],r=t.form,n=t.params;let s=null;void 0!==t.returnType&&(s=t.returnType),t.variable instanceof WailVariable&&(t.variable.value=i+e),a.copyBuffer(Uint8ToArray(r)),a.copyBuffer(VarUint32ToArray(n.length)),a.copyBuffer(n),null!==s?(a.copyBuffer(Uint8ToArray(1)),a.copyBuffer(Uint8ToArray(s))):a.copyBuffer(Uint8ToArray(0))}const c=a.write(),l=VarUint32ToArray(c.length);this.copyBuffer(l),this.copyBuffer(c)}_addImportSection(){const e=new BufferReader,t=this._sectionOptions[SECTION_IMPORT].newEntries,i=VarUint32ToArray(t.length);e.copyBuffer(i);let r=0,n=0;for(let i=0;i<t.length;i++){const a=t[i],o=stringToByteArray(a.moduleStr),s=VarUint32ToArray(o.length),_=stringToByteArray(a.fieldStr),c=VarUint32ToArray(_.length),l=[a.kind];let f;if(a.kind==KIND_FUNC){if(a.type instanceof TypedWailVariable)f=a.type.value;else{if(a.type instanceof WailVariable)throw new Error("Untyped WailVariable in _addImportSection()");f=VarUint32ToArray(a.type)}a.variable instanceof WailVariable&&(a.variable.value=this._importFuncCount+r++)}else a.kind==KIND_GLOBAL&&(f=[a.type,a.mutability],a.variable instanceof WailVariable&&(a.variable.value=this._importGlobalCount+n++));e.copyBuffer(s),e.copyBuffer(o),e.copyBuffer(c),e.copyBuffer(_),e.copyBuffer(l),e.copyBuffer(f)}const a=e.write(),o=VarUint32ToArray(a.length);this.copyBuffer([SECTION_IMPORT]),this.copyBuffer(o),this.copyBuffer(a);const s=this._sectionOptions[SECTION_FUNCTION].pending;for(let e=0;e<s.length;e++){const t=s[e].oldIndex;s[e].variable.value=this._getAdjustedFunctionIndex(t)}const _=this._sectionOptions[SECTION_GLOBAL].pending;for(let e=0;e<_.length;e++){const t=_[e].oldIndex;_[e].variable.value=this._getAdjustedGlobalIndex(t)}}_parseImportSection(){this.commitBytes();const e=this.readVarUint32(),t=this.inPos,i=this.readVarUint32(),r=this.inPos-t,n=this.readBytes(e-r),a=new BufferReader(n),o=this._sectionOptions[SECTION_IMPORT].newEntries,s=this._sectionOptions[SECTION_IMPORT].existingEntries;for(let e=0;e<i;e++){a.commitBytes();let t=a.readVarUint32(),i=a.readBytes(t),r=a.readVarUint32(),n=a.readBytes(r);for(let a=0;a<s.length;a++){const o=s[a];e==o.index&&(void 0!==o.moduleStr&&(i=o.moduleStr,t=o.moduleStr.length),void 0!==o.fieldStr&&(n=o.fieldStr,r=o.fieldStr.length))}a.copyBuffer(VarUint32ToArray(t)),a.copyBuffer(i),a.copyBuffer(VarUint32ToArray(r)),a.copyBuffer(n);const o=a.readUint8();if(o==KIND_FUNC)this._importFuncCount++,a.readVarUint32();else if(o==KIND_TABLE){a.readUint8();const e=a.readUint8();a.readVarUint32(),e&&a.readVarUint32()}else if(o==KIND_MEMORY){const e=a.readUint8();a.readVarUint32(),e&&a.readVarUint32()}else{if(o!=KIND_GLOBAL)throw"Invalid type kind: "+o;this._importGlobalCount++,a.readUint8(),a.readUint8()}}let _=i,c=0,l=0;for(let e=0;e<o.length;e++,_++){a.commitBytes();const t=o[e],i=stringToByteArray(t.moduleStr),r=VarUint32ToArray(i.length),n=stringToByteArray(t.fieldStr),s=VarUint32ToArray(n.length),_=[t.kind];let f;if(t.kind==KIND_FUNC){if(t.type instanceof TypedWailVariable)f=t.type.value;else{if(t.type instanceof WailVariable)throw new Error("Untyped WailVariable in _addImportSection()");f=VarUint32ToArray(t.type)}t.variable instanceof WailVariable&&(t.variable.value=this._importFuncCount+c),c++}else t.kind==KIND_GLOBAL&&(f=[t.type,t.mutability],t.variable instanceof WailVariable&&(t.variable.value=this._importGlobalCount+l),l++);a.copyBuffer(r),a.copyBuffer(i),a.copyBuffer(s),a.copyBuffer(n),a.copyBuffer(_),a.copyBuffer(f)}const f=VarUint32ToArray(_),O=a.write(),u=VarUint32ToArray(f.length+O.length);this.copyBuffer(u),this.copyBuffer(f),this.copyBuffer(O),0==this._resolvedTables&&this._resolveTableIndices()}_addFunctionSection(){const e=new BufferReader,t=this._sectionOptions[SECTION_FUNCTION].newEntries,i=VarUint32ToArray(t.length);e.copyBuffer(i);for(let i=0;i<t.length;i++){let r,n=t[i];if(n.type instanceof TypedWailVariable)r=n.type.value;else{if(n.type instanceof WailVariable)throw new Error("Untyped WailVariable in _parseFunctionSection()");r=VarUint32ToArray(n.type)}if(e.copyBuffer(r),n.variable instanceof WailVariable){const e=newCount+this._importFuncCount;n.variable.value=this._getAdjustedFunctionIndex(e)}}const r=e.write(),n=VarUint32ToArray(r.length);this.copyBuffer([SECTION_FUNCTION]),this.copyBuffer(n),this.copyBuffer(r)}_parseFunctionSection(){this.commitBytes();const e=this._sectionOptions[SECTION_FUNCTION].newEntries,t=this._sectionOptions[SECTION_FUNCTION].existingEntries,i=this.readVarUint32(),r=this.inPos,n=this.readVarUint32(),a=this.inPos-r,o=this.readBytes(i-a),s=new BufferReader(o);for(let e=0;e<n;e++){s.commitBytes();let i=s.readVarUint32();for(let r=0;r<t.length;r++){const n=t[r];e==n.index&&(i=n.type)}s.copyBuffer(VarUint32ToArray(i))}let _=n;for(let t=0;t<e.length;t++,_++){let i,r=e[t];if(r.type instanceof TypedWailVariable)i=r.type.value;else{if(r.type instanceof WailVariable)throw new Error("Untyped WailVariable in _parseFunctionSection()");i=VarUint32ToArray(r.type)}if(s.copyBuffer(i),r.variable instanceof WailVariable){const e=_+this._importFuncCount;r.variable.value=this._getAdjustedFunctionIndex(e)}}const c=VarUint32ToArray(_),l=s.write(),f=VarUint32ToArray(c.length+l.length);this.copyBuffer(f),this.copyBuffer(c),this.copyBuffer(l)}_addGlobalSection(){const e=new BufferReader,t=this._sectionOptions[SECTION_GLOBAL].newEntries,i=VarUint32ToArray(t.length);e.copyBuffer(i);for(let i=0;i<t.length;i++){const r=t[i];e.copyBuffer(Uint8ToArray(r.globalType.contentType)),e.copyBuffer(Uint8ToArray(r.globalType.mutability));const n=this._expandArrayVariables(r.initExpr);e.copyBuffer(n),r.variable instanceof WailVariable&&(r.variable.value=this._importGlobalCount+i)}const r=e.write(),n=VarUint32ToArray(r.length);this.copyBuffer([SECTION_GLOBAL]),this.copyBuffer(n),this.copyBuffer(r)}_parseGlobalSection(){this.commitBytes();const e=this.readVarUint32(),t=this.inPos,i=this.readVarUint32(),r=this.inPos-t,n=this.readBytes(e-r),a=new BufferReader(n),o=this._sectionOptions[SECTION_GLOBAL].newEntries,s=this._sectionOptions[SECTION_GLOBAL].existingEntries,_=i+o.length;a.copyBuffer(VarUint32ToArray(_));for(let e=0;e<i;e++){let t,i;for(let r=0;r<s.length;r++){const n=s[r];let a=n.index;a instanceof WailVariable&&(a=a.value),e==a&&(t=n.globalType.contentType,i=n.globalType.mutability)}a.readUint8();void 0!==t&&a.copyBuffer([t]),a.commitBytes();let r;a.readUint8();void 0!==i&&a.copyBuffer([i]);do{r=this._readInstruction(a)}while(r[0]!=OP_END);a.commitBytes()}for(let e=0;e<o.length;e++){const t=o[e];a.copyBuffer([t.globalType.contentType]),a.copyBuffer([t.globalType.mutability]),a.copyBuffer(this._expandArrayVariables(t.initExpr)),t.variable instanceof WailVariable&&(t.variable.value=this._importGlobalCount+i+e)}const c=a.write(),l=VarUint32ToArray(c.length);this.copyBuffer(l),this.copyBuffer(c)}_addExportSection(){const e=new BufferReader,t=this._sectionOptions[SECTION_EXPORT].newEntries,i=VarUint32ToArray(t.length);e.copyBuffer(i);for(let i=0;i<t.length;i++){const r=t[i],n=stringToByteArray(r.fieldStr),a=VarUint32ToArray(n.length),o=Uint8ToArray(r.kind);let s;if(r.index instanceof TypedWailVariable)s=r.index.value;else{if(r.index instanceof WailVariable)throw new Error("Untyped WailVariable in _parseExportSection()");s=VarUint32ToArray(r.index)}e.copyBuffer(a),e.copyBuffer(n),e.copyBuffer(o),e.copyBuffer(s)}const r=e.write(),n=VarUint32ToArray(r.length);this.copyBuffer([SECTION_EXPORT]),this.copyBuffer(n),this.copyBuffer(r)}_parseExportSection(){this.commitBytes();const e=this.readVarUint32(),t=this.readBytes(e),i=new BufferReader(t),r=i.readVarUint32(),n=this._sectionOptions[SECTION_EXPORT].newEntries,a=this._sectionOptions[SECTION_EXPORT].existingEntries,o=r+n.length;i.copyBuffer(VarUint32ToArray(o));for(let e=0;e<r;e++){i.commitBytes();let t,r=i.readVarUint32(),n=i.readBytes(r),o=i.readUint8(),s=i.readVarUint32();for(let t=0;t<a.length;t++){const i=a[t];e==i.index&&(void 0!==i.fieldStr&&(n=i.fieldStr,r=i.fieldStr.length),void 0!==i.kind&&(o=i.kind),void 0!==i.funcIndex&&(s=i.funcIndex))}s instanceof WailVariable?t=s.value:o==KIND_FUNC?t=this._getAdjustedFunctionIndex(s):o==KIND_GLOBAL&&(t=this._getAdjustedGlobalIndex(s)),i.copyBuffer(VarUint32ToArray(r)),i.copyBuffer(n),i.copyBuffer([o]),i.copyBuffer(VarUint32ToArray(t))}for(let e=0;e<n.length;e++){const t=n[e],r=stringToByteArray(t.fieldStr),a=VarUint32ToArray(r.length),o=Uint8ToArray(t.kind);let s;if(t.index instanceof TypedWailVariable)s=t.index.value;else{if(t.index instanceof WailVariable)throw new Error("Untyped WailVariable in _parseExportSection()");s=VarUint32ToArray(t.index)}i.copyBuffer(a),i.copyBuffer(r),i.copyBuffer(o),i.copyBuffer(s)}const s=i.write(),_=VarUint32ToArray(s.length);this.copyBuffer(_),this.copyBuffer(s)}_parseStartSection(){this.commitBytes();this.readVarUint32();const e=this.readVarUint32(),t=this._sectionOptions[SECTION_START].existingEntries;let i;if(t.length>0)for(let e=0;e<t.length;e++){const r=t[e];if("number"==typeof r)i=r;else{if(!(r instanceof WailVariable))throw new Error("Invalid function index in _parseStartSection()");i=r.value}}else i=this._getAdjustedFunctionIndex(e);const r=VarUint32ToArray(i),n=VarUint32ToArray(r.length);this.copyBuffer(n),this.copyBuffer(r)}_addElementSection(){const e=new BufferReader,t=this._sectionOptions[SECTION_ELEMENT].newEntries,i=VarUint32ToArray(t.length);e.copyBuffer(i);for(let i=0;i<t.length;i++,newCount++){const r=t[i],n=r.index;if(0!=n)throw new Error("Unsupported element index "+n);const a=r.offset,o=this._expandArrayVariables(r.elems),s=o.length;e.copyBuffer(VarUint32ToArray(n)),e.copyBuffer(a),e.copyBuffer(VarUint32ToArray(s)),e.copyBuffer(o)}const r=e.write(),n=VarUint32ToArray(r.length);this.copyBuffer([SECTION_ELEMENT]),this.copyBuffer(n),this.copyBuffer(r)}_parseElementSection(){this.commitBytes();const e=this.readVarUint32(),t=this.inPos,i=this.readVarUint32(),r=this.inPos-t,n=this.readBytes(e-r),a=new BufferReader(n),o=this._sectionOptions[SECTION_ELEMENT].newEntries,s=this._sectionOptions[SECTION_ELEMENT].existingEntries;for(let e=0;e<i;e++){let t;a.readVarUint32();do{t=this._readInstruction(a)}while(t[0]!=OP_END);a.commitBytes();let i=a.readVarUint32(),r=[];for(let e=0;e<i;e++){const e=a.readVarUint32(),t=this._getAdjustedFunctionIndex(e);r.push(t)}for(let t=0;t<s.length;t++){const n=s[t];e==n.index&&void 0!==n.elems&&(i=(r=n.elems).length)}a.copyBuffer(VarUint32ToArray(i));for(let e=0;e<i;e++)a.copyBuffer(VarUint32ToArray(r[e]))}let _=i;for(let e=0;e<o.length;e++,_++){const t=o[e],i=t.index;if(0!=i)throw new Error("Unsupported element index "+i);const r=t.offset,n=this._expandArrayVariables(t.elems),s=n.length;a.copyBuffer(VarUint32ToArray(i)),a.copyBuffer(r),a.copyBuffer(VarUint32ToArray(s)),a.copyBuffer(n)}const c=a.write(),l=VarUint32ToArray(_),f=VarUint32ToArray(l.length+c.length);this.copyBuffer(f),this.copyBuffer(l),this.copyBuffer(c)}_addCodeSection(){const e=new BufferReader,t=this._sectionOptions[SECTION_CODE].newEntries,i=VarUint32ToArray(t.length);e.copyBuffer(i);const r=e.write(),n=VarUint32ToArray(r.length);this.copyBuffer([SECTION_CODE]),this.copyBuffer(n),this.copyBuffer(r)}_parseCodeSection(){this.commitBytes();const e=this.readVarUint32(),t=this.readBytes(e),i=new BufferReader(t),r=i.readVarUint32(),n=this._sectionOptions[SECTION_CODE].newEntries,a=r+n.length;i.copyBuffer(VarUint32ToArray(a));for(let e=0;e<r;e++){const t=this._getAdjustedFunctionIndex(this._importFuncCount+e);this._readFunction(i,t)}for(let e=r;e<a;e++){const t=this._funcSectionIndexToFuncTableIndex(e),r=new BufferReader;let a,o=!1;for(let e=0;e<n.length;e++){let i=(a=n[e]).index;if(i instanceof WailVariable&&(i=i.value),i==t){o=!0;break}}if(!o)throw new Error("No CODE entry found for index "+t);let s=a.locals,_=a.code;r.copyBuffer(VarUint32ToArray(s.length));for(let e=0;e<s.length;e++){const t=s[e];r.copyBuffer(VarUint32ToArray(1)),r.copyBuffer(Uint8ToArray(t))}_=this._expandArrayVariables(_),r.copyBuffer(_);const c=r.write(),l=VarUint32ToArray(c.length);i.copyBuffer(l),i.copyBuffer(c)}const o=i.write(),s=VarUint32ToArray(o.length);this.copyBuffer(s),this.copyBuffer(o)}_addDataSection(){const e=new BufferReader,t=this._sectionOptions[SECTION_DATA].newEntries,i=VarUint32ToArray(t.length);e.copyBuffer(i);for(let i=0;i<t.length;i++){const r=t[i];let n;n=void 0!==r.index?VarUint32ToArray(r.index):VarUint32ToArray(0);const a=r.offset;a[a.length-1]!=OP_END&&a.push(OP_END);const o=r.data,s=VarUint32ToArray(o.length);e.copyBuffer(n),e.copyBuffer(a),e.copyBuffer(s),e.copyBuffer(o)}const r=e.write(),n=VarUint32ToArray(r.length);this.copyBuffer([SECTION_DATA]),this.copyBuffer(n),this.copyBuffer(r)}_parseDataSection(){this.commitBytes();const e=this.readVarUint32(),t=this.inPos,i=this.readVarUint32(),r=this.inPos-t,n=this.readBytes(e-r),a=new BufferReader(n),o=this._sectionOptions[SECTION_DATA].newEntries,s=this._sectionOptions[SECTION_DATA].existingEntries,_=i+o.length;a.copyBuffer(VarUint32ToArray(_));for(let e=0;e<i;e++){let t;do{t=this._readInstruction(a)}while(t[0]!==OP_END);a.commitBytes();let i=a.readVarUint32(),r=a.readBytes(i);for(let t=0;t<s.length;t++){const n=s[t];e==n.index&&void 0!==n.data&&(i=(r=n.data).length)}a.copyBuffer(VarUint32ToArray(i)),a.copyBuffer(r)}for(let e=0;e<o.length;e++){const t=o[e];let i;i=void 0!==t.index?VarUint32ToArray(t.index):VarUint32ToArray(0);const r=t.offset;r[r.length-1]!=OP_END&&r.push(OP_END);const n=t.data,s=VarUint32ToArray(n.length);a.copyBuffer(i),a.copyBuffer(r),a.copyBuffer(s),a.copyBuffer(n)}const c=a.write(),l=VarUint32ToArray(c.length);this.copyBuffer(l),this.copyBuffer(c)}_readFunction(e,t){const i=this._sectionOptions[SECTION_CODE].existingEntries,r=e.readVarUint32(),n=e.readBytes(r),a=new BufferReader(n),o=a.readVarUint32();for(let e=0;e<o;e++)a.readVarUint32(),a.readUint8();a.commitBytes();const s=new BufferReader(n.subarray(a.inPos));for(;s.inPos<s.inBuffer.length;)this._readInstruction(s),s.commitBytes();let _=a.write(),c=s.write();if("function"==typeof this._globalFunctionCallback){const e={};e.bytes=s.write(),e.index=t;const i=this._globalFunctionCallback(e);!1!==i&&(c=i)}else for(let e=0;e<this._functionCallbacks.length;e++){const i=this._functionCallbacks[e];let r=i.index;if(r instanceof WailVariable&&(r=r.value),r===t){const e={};e.bytes=s.write(),e.index=t;const r=i.callback(e);!1!==r&&(c=r)}}for(let e=0;e<i.length;e++){const r=i[e];let n=r.index;if(n instanceof WailVariable&&(n=n.value),t==n){const e=new BufferReader,t=r.locals;e.copyBuffer(VarUint32ToArray(t.length));for(let i=0;i<t.length;i++){const r=t[i];e.copyBuffer(VarUint32ToArray(1)),e.copyBuffer(Uint8ToArray(r))}const i=this._expandArrayVariables(r.code);e.copyBuffer(i),c=e.write()}}let l=VarUint32ToArray(_.length+c.length);e.copyBuffer(l),e.copyBuffer(_),e.copyBuffer(c)}_readInstruction(e){e.commitBytes(),e.setAnchor();const t=e.readUint8();let i,r;switch(t){case OP_UNREACHABLE:case OP_NOP:case OP_ELSE:case OP_END:case OP_RETURN:case OP_DROP:case OP_SELECT:case OP_I32_EQZ:case OP_I32_EQ:case OP_I32_NE:case OP_I32_LT_S:case OP_I32_LT_U:case OP_I32_GT_S:case OP_I32_GT_U:case OP_I32_LE_S:case OP_I32_LE_U:case OP_I32_GE_S:case OP_I32_GE_U:case OP_I64_EQZ:case OP_I64_EQ:case OP_I64_NE:case OP_I64_LT_S:case OP_I64_LT_U:case OP_I64_GT_S:case OP_I64_GT_U:case OP_I64_LE_S:case OP_I64_LE_U:case OP_I64_GE_S:case OP_I64_GE_U:case OP_F32_EQ:case OP_F32_NE:case OP_F32_LT:case OP_F32_GT:case OP_F32_LE:case OP_F32_GE:case OP_F64_EQ:case OP_F64_NE:case OP_F64_LT:case OP_F64_GT:case OP_F64_LE:case OP_F64_GE:case OP_I32_CLZ:case OP_I32_CTZ:case OP_I32_POPCNT:case OP_I32_ADD:case OP_I32_SUB:case OP_I32_MUL:case OP_I32_DIV_S:case OP_I32_DIV_U:case OP_I32_REM_S:case OP_I32_REM_U:case OP_I32_AND:case OP_I32_OR:case OP_I32_XOR:case OP_I32_SHL:case OP_I32_SHR_S:case OP_I32_SHR_U:case OP_I32_ROTL:case OP_I32_ROTR:case OP_I64_CLZ:case OP_I64_CTZ:case OP_I64_POPCNT:case OP_I64_ADD:case OP_I64_SUB:case OP_I64_MUL:case OP_I64_DIV_S:case OP_I64_DIV_U:case OP_I64_REM_S:case OP_I64_REM_U:case OP_I64_AND:case OP_I64_OR:case OP_I64_XOR:case OP_I64_SHL:case OP_I64_SHR_S:case OP_I64_SHR_U:case OP_I64_ROTL:case OP_I64_ROTR:case OP_F32_ABS:case OP_F32_NEG:case OP_F32_CEIL:case OP_F32_FLOOR:case OP_F32_TRUNC:case OP_F32_NEAREST:case OP_F32_SQRT:case OP_F32_ADD:case OP_F32_SUB:case OP_F32_MUL:case OP_F32_DIV:case OP_F32_MIN:case OP_F32_MAX:case OP_F32_COPYSIGN:case OP_F64_ABS:case OP_F64_NEG:case OP_F64_CEIL:case OP_F64_FLOOR:case OP_F64_TRUNC:case OP_F64_NEAREST:case OP_F64_SQRT:case OP_F64_ADD:case OP_F64_SUB:case OP_F64_MUL:case OP_F64_DIV:case OP_F64_MIN:case OP_F64_MAX:case OP_F64_COPYSIGN:case OP_I32_WRAP_I64:case OP_I32_TRUNC_S_F32:case OP_I32_TRUNC_U_F32:case OP_I32_TRUNC_S_F64:case OP_I32_TRUNC_U_F64:case OP_I64_EXTEND_S_I32:case OP_I64_EXTEND_U_I32:case OP_I64_TRUNC_S_F32:case OP_I64_TRUNC_U_F32:case OP_I64_TRUNC_S_F64:case OP_I64_TRUNC_U_F64:case OP_F32_CONVERT_S_I32:case OP_F32_CONVERT_U_I32:case OP_F32_CONVERT_S_I64:case OP_F32_CONVERT_U_I64:case OP_F32_DEMOTE_F64:case OP_F64_CONVERT_S_I32:case OP_F64_CONVERT_U_I32:case OP_F64_CONVERT_S_I64:case OP_F64_CONVERT_U_I64:case OP_F64_PROMOTE_F32:case OP_I32_REINTERPRET_F32:case OP_I64_REINTERPRET_F64:case OP_F32_REINTERPRET_I32:case OP_F64_REINTERPRET_I64:break;case OP_BLOCK:case OP_LOOP:case OP_IF:case OP_MEMORY_SIZE:case OP_MEMORY_GROW:e.readUint8();break;case OP_BR:case OP_BR_IF:case OP_GET_LOCAL:case OP_SET_LOCAL:case OP_TEE_LOCAL:case OP_I32_CONST:case OP_I64_CONST:e.readVarUint32();break;case OP_GET_GLOBAL:case OP_SET_GLOBAL:e.commitBytes(),i=e.readVarUint32(),r=this._getAdjustedGlobalIndex(i),e.copyBuffer(VarUint32ToArray(r));break;case OP_F32_CONST:e.readBytes(4);break;case OP_F64_CONST:e.readBytes(8);break;case OP_I32_LOAD:case OP_I64_LOAD:case OP_F32_LOAD:case OP_F64_LOAD:case OP_I32_LOAD8_S:case OP_I32_LOAD8_U:case OP_I32_LOAD16_S:case OP_I32_LOAD16_U:case OP_I64_LOAD8_S:case OP_I64_LOAD8_U:case OP_I64_LOAD16_S:case OP_I64_LOAD16_U:case OP_I64_LOAD32_S:case OP_I64_LOAD32_U:case OP_I32_STORE:case OP_I64_STORE:case OP_F32_STORE:case OP_F64_STORE:case OP_I32_STORE8:case OP_I32_STORE16:case OP_I64_STORE8:case OP_I64_STORE16:case OP_I64_STORE32:e.readVarUint32(),e.readVarUint32();break;case OP_BR_TABLE:const n=e.readVarUint32();for(let t=0;t<n;t++)e.readVarUint32();e.readVarUint32();break;case OP_CALL:e.commitBytes(),i=e.readVarUint32(),r=this._getAdjustedFunctionIndex(i),e.copyBuffer(VarUint32ToArray(r));break;case OP_CALL_INDIRECT:e.readVarUint32(),e.readUint8();break;default:throw new Error("Unknown opcode '"+t+"'. Probably parsing incorrectly")}if(e.commitBytes(),void 0!==this._instructionCallbacks[t]){const i=e.readFromAnchor(),r=this._instructionCallbacks[t](i);e.writeAtAnchor(r)}else if("function"==typeof this._globalInstructionCallback){const i=e.readFromAnchor(),r=this._globalInstructionCallback[t](i);e.writeAtAnchor(r)}return e.readFromAnchor()}_funcSectionIndexToFuncTableIndex(e){return e+this._importFuncCount+this._importFuncNewCount}_getAdjustedFunctionIndex(e){return e>=this._importFuncCount?e+this._importFuncNewCount:e}_getAdjustedGlobalIndex(e){return e>=this._importGlobalCount?e+this._importGlobalNewCount:e}}
